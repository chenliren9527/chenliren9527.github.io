---
title: 黑马旅游(04)
tags:
  - 笔记
  - 数据库
  - redis
  - 黑马旅游
  - NOSql
categories:
  - JavaWeb
abbrlink: 59233
date: 2020-10-28 20:28:10
---

## 01.反馈-学习目标

1. NoSQL介绍

2. Redis入门

3. Jedis入门

4. 黑马旅游网缓存应用



## 02.NOSql：介绍与好处【理解】

### 目标

理解NOSql的概念

理解NOSql的好处



### NOSql介绍

Not Only Sql  不仅仅是sql, 泛指非关系型数据库

非关系型数据库里面有一个很重要类型数据库： 缓存数据库， 因为里面存储的数据没有任何关系



mysql： 关系型数据库

![1603846016221](黑马旅游-04.assets/1603846016221.png)

**redis:  非关系型数据库:** 数据与数据之间没有任何的关系



### 非关系与关系型数据库的区别

关系型数据库

> 优点： 
>
> ​		是磁盘数据库，数据永久保存在磁盘上，所以数据安全
>
> 缺点：
>
> ​		就是慢
>
> ​        原因1： 磁盘数据库的续写是IO的读写
>
> ​        原因2： 关系型数据库有各种约束、检查、事务操作等逻辑控制

(redis)非关系型数据库

> 优点
>
> ​	 就是快， 因为是内存的操作
>
> 缺点
>
> ​	数据不安全，会容易丢失部分数据

### 以后到底使用哪种类型数据库?

redis作为缓存的应用时：关系型和非关系型都使用

（放入到redis的数据一般都是修改频率比较低的数据）

![1552060757597](黑马旅游-04.assets/1552060757597.png)

海量的访问先访问NOSql， NOsql中没有数，会访问mysql的数据写入到NOSql中， 海里的访问都会访问到NOSql中的数据

### 小结

什么是关系型数据库？什么是非关系型数据库?

>关系型数据库的特点： 数据与数据之间是有关系的。
>
>非关系型数据的特点：  数据与数据之间是没有关系。
>
>

NOSql的好处

> 内存操作，速度快，适合解决高并发海量的请求



## 03.NOSql：Redis介绍与安装【理解】

### 目标

掌握redis的安装



### 非关系型数据库的产品

![1547170777788](黑马旅游-04.assets/1547170777788.png)&nbsp;

| 分类         | 特点                                                     | 代表产品 |
| ------------ | -------------------------------------------------------- | -------- |
| 键值存储     | 数据一般存在内存中，读写速度快(10w/s)，适合作为缓存服务  | redis    |
| 文档型数据库 | 数据结构要求不严格，适合存储结构不确定或者价值较低的数据 | mongdb   |
| 列存储数据库 | 查找速度快，更容易进行分布式扩展，适合作为文件存储服务   | Hbase    |
| 图形数据库   | 使用“图结构”进行存储，适合做社交网络计算等等             | Neo4j    |



### redis存储数据特点

以key-value键值对存储

### redis安装与目录介绍

1. 下载

   windows版本，适合开发学习，https://github.com/MSOpenTech/redis/tags   微软提供的

   ![1566784243907](黑马旅游-04.assets/1566784243907.png)

   linux版本，适合正式环境，官方提供的http://redis.io/download 

   ![1566784297672](黑马旅游-04.assets/1566784297672.png)

   > 注意： 官方只提供了linux版本的redis,  windows版本时微软的模仿版
   >
   > 习惯： 生产环境使用linux版本，个人开发学习使用windows版本

   大家不需要下载，因为软件目录中提供了

   ![1566784332962](黑马旅游-04.assets/1566784332962.png)

2. 解压完成安装

   ![1566784388416](黑马旅游-04.assets/1566784388416.png)

3. 介绍redis的目录结构

   ![1547171360803](黑马旅游-04.assets/1547171360803.png)&nbsp;

### 使用redis存储数据体验步骤

1. 双击运行redis服务器端redis-server.exe（服务器启动后会根据电脑内存相等的大小大小占用磁盘空间）

   ![1552094267699](黑马旅游-04.assets/1552094267699.png)

2. 双击运行redis客户端redis-cli.exe

3. 在客户端上进行存取数据

   ![1552094281118](黑马旅游-04.assets/1552094281118.png)

### 常见问题

问题： 双击服务器端打不开？

解决方案：redis服务器启动会占用当前磁盘系统内存相等大小的空间， 例如电脑内存16G， 启动时就会占磁盘16G的空间， 如果当前磁盘不够16G， 服务器就不能启动起来



如果还是启动不了，可以关闭idea，再试



如果上面方案解决不了：  重启电脑，再次打开

### 小结

* **redis是以什么方式存储数据的？**

- 键值对的方式存储数据

* redis客户端与服务器端软件的名字是什么？

  - redis-server redis服务端
  - redis-cli  redis客户端

* redis服务器使用的端口号是？

  - 6379

## 04.Redis五种数据介绍【理解】

### 目标

redis常见可以存储5种数据类型



### 类型介绍

![image-20200720100954455](黑马旅游-04.assets/image-20200720100954455.png)

### key的使用原则

1. key的长度不要超过1024个字节，否则会影响查询的性能
2. key的名字要有含义和可读性好

### 小结

* redis支持常用五种数据类型都有哪些？

  - string(重点)
  - hash（哈希） 
  - list（有序、可重复）
  - set(无序，不可重复)
  - zset(有序、不可重复) 

* 以后最常用使用哪种数据类型？

  - string(重点)



## 05.数据类型1：String命令【重点】

### 目标

掌握String命令操作数据增、删、改、查



### 介绍

字符串类型是 Redis 中最为基础的数据存储类型，它在 Redis 中以二进制保存，没有编码和解码的过程。无论存入的是字符串、整数、浮点类型都会以字符串写入。在 Redis 中字符串类型的 Value 最多可以容纳的数据长度是 512M。这是以后最常用的数据类型。

![1566780339811](黑马旅游-04.assets/1566780339811.png)

### 操作命令语法

![1547172775342](黑马旅游-04.assets/1547172775342.png)

### String操作命令

![1547172885046](黑马旅游-04.assets/1547172885046.png)

### String适合操作的数据

适合操作所有数据： 比如缓存导航分类列表数据，将分类列表 `List<T>`  转换为json字符串进行存储



### 小结

* **string类型增加数据、修改数据命令**

  ​    set key  value

* **string类型查询数据命令**

  ​	get key 

* **string类型删除数据命令**

  del  key

  


## 06.数据类型2：hash命令【理解】

### 目标

掌握hash类型数据增、删、改、查

### 介绍

Redis 中的 Hash 类型可以看成具 String 的键和 String 的值 Map 容器，每一个 Hash 可以存储 40（42 亿 9千多个）亿个键值对。

> string类型存储的value大小限制512MB

![1566780213276](黑马旅游-04.assets/1566780213276-1595171237405.png)

![1603848770489](黑马旅游-04.assets/1603848770489.png)



### 操作命令语法

![1547173339215](黑马旅游-04.assets/1547173339215-1595171237407.png)



### 操作

![1547173800532](黑马旅游-04.assets/1547173800532-1595171237407.png)

### 扩展命令

hlen 获取hash类型指定key的field数

> 语法:  hlen key

 HEXISTS 判断hash中指定key的指定字段是否存在

> 语法: HEXISTS key  field1 

Hincrby 命令用于为哈希表中的字段值加上指定增量值。

> 语法:  HINCRBY key   field  增量值

### Hash适合操作的数据

适合缓存存储结构较复杂的数据，例如：购物车数据

存储购物车数据

![image-20200623081736294](黑马旅游-04.assets/image-20200623081736294.png) 

例如

```mackdown
用户1：user1
商品1  id=p001   购物数量=2
商品2  id=p002   购物数量=1

用户2：user2
商品1  id=p003   购物数量=2
商品2  id=p004   购物数量=1
```

命令

```redis
hmset user1 p001 2 p002 1
hmset user2 p003 2 p004 1
```

### 小结

* **hash增加或修改数据命令？**

  - hset key field  value
  - hmset key field1 vlaue1 field2 value2..

* **hash查询数据命令？**

  - hget key field 
  - hgetall  

* **hash删除数据命令？**

  - hdel key field1 field2..

  

## 07.数据类型3：list命令【理解】

### 目标

理解list类型数据增、删、改、查



### list介绍

在 Redis 中，List 类型是按照插入顺序排序的字符串链表。和数据结构中的==普通链表==(java的LinkedList)一样，我们可以在其左部(left)和右部(right)添加新的元素。在插入时，如果该键并不存在，Redis 将为该键创建一个新的链表，如果这个键已经存在，则是向 list 添加元素。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List 中可以包含的最大元素数量是 40 亿个。可以实现队列（先进先出）和栈（先进后出）

![1566780090080](黑马旅游-04.assets/1566780090080-1595171237407.png)



### 添加元素语法

![1547174788423](黑马旅游-04.assets/1547174788423-1595171237408.png)

操作

![1547174878543](黑马旅游-04.assets/1547174878543-1595171237408.png)

效果

![1547174890883](黑马旅游-04.assets/1547174890883-1595171237408.png)

### 查询数据语法

![1547175103829](黑马旅游-04.assets/1547175103829-1595171237408.png)

效果

![1603849825645](黑马旅游-04.assets/1603849825645.png)



### 删除元素语法

![1547175236407](黑马旅游-04.assets/1547175236407-1595171237408.png)

效果

![1547175311992](黑马旅游-04.assets/1547175311992-1595171237408.png)&nbsp;

### 查看列表的长度

![1547175350084](黑马旅游-04.assets/1547175350084-1595171237408.png)

![1547175394085](黑马旅游-04.assets/1547175394085-1595171237411.png)&nbsp;

### 扩展命令

1、查询指定位置的元素

```redis
lindex key 位置
```

![1603850039524](黑马旅游-04.assets/1603850039524.png)

2、修改指定位置元素值

```redis
lset key 位置 元素新值
```

![1603850110172](黑马旅游-04.assets/1603850110172.png)

3、给指定元素前后插入数据，从左到右匹配第一个符合的元素插入

```java
LINSERT key BEFORE|AFTER 已有元素值 新元素值
```

![1603850216352](黑马旅游-04.assets/1603850216352.png)

4、删除指定元素值数据命令

```java
LREM KEY 数量 元素值
```

> - count > 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。
> - count < 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。
> - count = 0 : 移除表中所有与 VALUE 相等的值。

![1603850291547](黑马旅游-04.assets/1603850291547.png)

### list适合操作的数据

缓存定时排行榜

定时排行榜介绍：list类型的lrange命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在list类型中，如京东每日的手机销量排行、学校每次月考学生的成绩排名、斗鱼年终盛典主播排名等，下图是酷狗音乐“K歌擂台赛”的昨日打擂金曲排行榜，每日计算一次，存储在list类型中，接口访问时，通过page和size分页获取打擂金曲。

![image-20200623082210165](黑马旅游-04.assets/image-20200623082210165.png) 

举例： 将一个表中大量的数据进行降序排序计算（数据量不同，计算时间不等），将计算结果按照顺序写入redis中list类型里面



### 小结

* list类型数据特点？

  ​    有序，可重复

* list类型增加数据命令？

  lpush   key  value1 value2

  rpush  key value1  value2 

* list类型查询数据命令？

  lrange key 开始索引值 结束索引值

  lindex key  索引值

* list类型删除数据命令？

  lrem key  数量 元素

  


## 08.数据类型4：set命令【理解】

### 目标

掌握set命令数据增、删、查命令

### 特点

​	set数据类型特点： 无序、不可重复

### 介绍

在 Redis 中，我们可以将 Set 类型看作为没有排序的字符集合，和 List 类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。Set 可包含的最大元素数量是 40 亿，和 List 类型不同的是，Set 集合中不允许出现重复的元素。

![1566780177090](黑马旅游-04.assets/1566780177090-1595171237411.png)

### 操作命令语法

存储数据特点：不可重复，无序

![1547175692108](黑马旅游-04.assets/1547175692108-1595171237412.png)

> 注意：set没有修改数据命令

### 效果

![1547176008535](黑马旅游-04.assets/1547176008535-1595171237412.png)

### set适合操作的数据

数据去重：存储不重复的数据，就可以使用set



### 小结

* set类型数据特点？

  元素不可重复，是无序

* set增加数据命令？

  sadd  key value1 value2 ...

* set查询数据命令？

  smembers key 

* set删除数据命令？

  srem key  value1 value2。。。


## 09.数据类型5：zset命令【理解】

### 目标

掌握zset（sorted set）类型数据增、删、查操作



### 介绍

sorted set 是有序(自然顺序)并且不可重复(value值不可以重复)

Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。

不同的是每个元素都会关联一个分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复，每个集合可存储40多亿个成员。

![1566741681703](黑马旅游-04.assets/1566741681703-1595171237412.png)

### Sorted Set(zset)常用命令

![1566741781005](黑马旅游-04.assets/1566741781005-1595171237412.png)

 zrange myZSet 0 -1 withscores 升序查询指定索引范围的数据，并显示值的分数

zrevrange myZSet 0 -1 withscores 降序查询指定索引范围的数据，并显示值的分数

zrevrank 键 值  降序查询指定元素的索引

> 注意：zset没有修改数据命令

### 命令演示

1)       添加键country，分数是10，值是Japan

2)       添加键country，分数是5，值是USA

3)       添加键country，分数是1，值是China，分数是120，值是Korea

4)       查询country中所有的元素

5)       查询Japan的索引号(从0开始)

6)       删除值为USA的元素

7)       查询country中还有多少个元素

### 效果

![1566741832784](黑马旅游-04.assets/1566741832784-1595171237412.png)&nbsp;

### ZSet适合操作的数据

各种实时排行榜

例如：微博热搜

![image-20200811021816030](黑马旅游-04.assets/image-20200811021816030.png)

![1603852447009](黑马旅游-04.assets/1603852447009.png)





## 10.图形客户端与通用命令【理解】

### 目标

掌握客户端redisDesktopManager的使用

掌握通用命令



### 客户端软件

直接安装提供的客户端软件即可，双击桌面图标执行。

 ![1566741529845](黑马旅游-04.assets/1566741529845-1595171237412.png)&nbsp;                                          

启动后出现如下登录界面：

 ![1566741545251](黑马旅游-04.assets/1566741545251-1595171237413.png)&nbsp;

![1550458634797](黑马旅游-04.assets/1550458634797-1595171237413.png)

![1550458621979](黑马旅游-04.assets/1550458621979-1595171237413.png)

<font color=red>注意：这个软件玩一下就好了，这个软件显示数据方面有问题，偶尔会出现服务器是有数据但是图形界面客户端显示null</font>

### 通用操作命令语法（任何一种数据类型都可以使用）

![1566740786239](黑马旅游-04.assets/1566740786239-1595171237414.png)

ttl的说明

![1571370133980](黑马旅游-04.assets/1571370133980-1595171237415.png)



![1571369987270](黑马旅游-04.assets/1571369987270-1595171237415.png)&nbsp;

### 扩展命令：setnx key value

> 将 `key` 的值设为 `value` ，当且仅当 `key` 不存在。
>
> 若给定的 `key` 已经存在，则 SETNX不做任何动作。
>
> SETNX是『SET if Not eXists』(如果不存在，则 SET)的简写。

作用

```
防止数据覆盖或重复设置数据
```

效果

![1547176883056](黑马旅游-04.assets/1547176883056-1595171237415.png)

​			 ![1566791231167](黑马旅游-04.assets/1566791231167-1595171237415.png)



## 11.持久化方式1：RDB策略【理解】

### 疑问

* redis服务器关闭所有内存数据都会丢失吗？

  答:  不会全部丢失, 只会丢失部分数据

   原因:  redis有持久化机制,  可以在符合条件的时候将内存中的数据持久化到磁盘上保存; 当服务器再次启动会自动恢复数据

* 为什么要保存到磁盘?

  答:  防止redis服务器突然崩溃,  redis可以重启之后立刻恢复磁盘的数据用于缓存; 这就是redis的持久化机制

  ​       如果没有redis持久化机制, 所有缓存数据丢失, 会造成磁盘数据库mysql瞬间压力增大, 有可能导致mysql崩溃



### 目标

理解RDB持久化策略



### RDB策略介绍（快照策略）

Redis DataBase(RDB) , 是redis的默认开启的持久化策略.   在符合持久化条件时会将这一时刻内存所有数据进行持久化到磁盘文件上dump.rdb,   由于持久化的是某一时刻所有内存数据又叫快照策略.



### RDB策略的配置

在配置文件redis.windows.conf文件中有配置的持久化条件

![image-20200623161903357](黑马旅游-04.assets/image-20200623161903357.png)

save 900 1

> 如果有1个以上的key发生改变(增删改),  那么900秒(15分钟)持久化一次数据到dump.rdb文件中

save 300 10

> 如果有10个以上的key发生改变(增删改),  那么300秒(5分钟)持久化一次数据到dump.rdb文件中

save 60 10000

> 如果有10000个以上的key发生改变(增删改),  那么60秒(1分钟)持久化一次数据到dump.rdb文件中

### 案例演示-采用RDB策略持久化数据测试

- 需求

  修改rdb持久化策略方案，设置20秒内修改3个键进行持久化数据到dump.rdb文件中

- 实现步骤

  1. 关闭redis服务器

  2. 编辑文件redis.windows.conf增加如下命令, 保存文件

     ![image-20200623162323319](黑马旅游-04.assets/image-20200623162323319.png)

  3. 进入dos命令并且进入redis服务器目录

     ![image-20200623162434736](黑马旅游-04.assets/image-20200623162434736.png)

     ![image-20200623162529770](黑马旅游-04.assets/image-20200623162529770.png)

     打开dos命令如图

     ![image-20200623162451062](黑马旅游-04.assets/image-20200623162451062.png)

  4. 执行命令如下

     ```redis
     redis-server.exe redis.windows.conf
     ```

     ![image-20200623162724178](黑马旅游-04.assets/image-20200623162724178.png)

     <font color=red>注意</font>

     双击redis-server.exe启动redis服务器，这样启动服务器一切采用默认配置；如果配置文件修改了，必须使用dos命令启动redis服务器并且指明配置文件，这样才可以应用修改后的配置文件数据

  5. 双击启动redis-cli.exe启动客户端

  6. 输入3次命令,观察输入后和到达20秒就立即持久化操作

     ![image-20200623163352464](黑马旅游-04.assets/image-20200623163352464.png)


### dump.rdb文件数据内容

![image-20200623163522641](黑马旅游-04.assets/image-20200623163522641.png)

上面不是乱码,是redis自己的持久化数据格式

### 小结

- ==rdb介绍?==

  是redis默认开启的持久化策略,  又叫快照策略,  在符合持久化条件时会将这一时刻内存全部数据写入磁盘文件dump.rdb中;

- rdb策略的优点？

  持久化频率低,  所以redis的缓存性能不会受到影响

- rdb策略的缺点？

  由于持久化频率低, 导致数据可能会丢失部分数据

  

## 12.持久化方式2：AOF策略【理解】

### 目标

理解AOF持久化策略



### AOF(append only file)策略介绍

##### 介绍

==这个策略默认没有开启,==  这个策略是每一秒将一秒内的增删改的命令持久化追加到appendonly.aof文件中



##### 配置

需要修改配置文件redis.windows.conf进行开启AOF策略，如下操作

![image-20200623165659041](黑马旅游-04.assets/image-20200623165659041.png)

![1547178984159](黑马旅游-04.assets/1547178984159-1595171237417.png)



开启AOF后，持久化策略有3个

![1547179028021](黑马旅游-04.assets/1547179028021-1595171237417.png)

AOF默认是采用的策略是每秒持久化一次，会导致持久化文件随着时间不断增大，AOF会记录每一个key所有修改操作的过程。

<font color=red>appendfsync no：含义不进行强制持久化，而是交给操作系统与redis自己决定持久化的频率；在aof里面性能最好，但是安全性最不好</font>

### 案例演示-采用AOF策略持久化数据测试

- 需求

  开启AOF策略进行持久化数据测试，观察其持久化数据的过程

- 实现步骤

  1.开启AOF, 保存文件

  ![image-20200623165745053](黑马旅游-04.assets/image-20200623165745053.png)


* 2. 关闭redis服务器与客户端

  3. 启动dos命令方式启动redis服务器端,  输入如下命令

     ```redis
     redis-server.exe redis.windows.conf
     ```

     ![image-20200623170221904](黑马旅游-04.assets/image-20200623170221904.png)

     ![image-20200623170351386](黑马旅游-04.assets/image-20200623170351386.png)

  4. 双击启动客户端,  每秒输入一次命令查看持久化效果

     ![image-20200623170552755](黑马旅游-04.assets/image-20200623170552755.png)

  

### 小结

- AOF介绍?

  是追加方式持久化策略(日志记录方式备份), 默认是没有开启 ,  开启后默认每秒将1秒内的增删改的命令追加到appendonly.aof文件中;

- AOF策略的优点?

  持久化频率高了,  数据安全性高,  ==数据不易丢失==,  最多丢失1秒内的数据

- AOF缺点？

  ==持久化频率高了,  redis的性能会受到影响,  如果持久化非常频繁会导致cpu的压力大==

* RDB和AOF以后到底推荐使用哪一个呢？

  如果希望数据安全性高，才开AOF，否则只建议使用RDB，因为AOF会降低redis的性能, 严重影响CPU（cpu超过60%都会选择关闭AOF）。注意AOF很影响redis的性能



## 13.Jedis客户端：基本使用【理解】

### 目标

掌握jedis的使用



### Jedis（java redis）介绍

是官方推荐的操作redis的java客户端

### Jedis的api方法

![1547180465875](黑马旅游-04.assets/1547180465875.png)

### jedis的使用步骤

1. 需要导入jedis的jar包(项目已经是导入了)

   ```xml
   <dependency>
     <groupId>redis.clients</groupId>
     <artifactId>jedis</artifactId>
     <version>2.9.0</version>
   </dependency>
   ```

2. 利用jedis的api操作redis

### jedis基本使用代码

```java
package com.itheima.test;

import org.junit.Test;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

import java.util.List;

/*
目标：jedis基本的使用
 */
public class JedisTest {

    //jedis基本的使用
    @Test
    public void test01(){
        //1. 创建jedis连接池的配置对象
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        //1.1 设置连接池最大的连接个数
        jedisPoolConfig.setMaxTotal(10);
        //1.2 设置获取连接最大的等待时间
        jedisPoolConfig.setMaxWaitMillis(30000); //单位毫秒  30秒

        //2. 创建jedis连接池
        JedisPool jedisPool = new JedisPool(jedisPoolConfig,"localhost",6379);

        //3. 获取到jedis
        Jedis jedis = jedisPool.getResource();

        //4. 操作(jedis的api与redis的命令方法是一模一样)
        jedis.set("name","张嘉文");
        //操作字符串类型
        String name = jedis.get("name");
        System.out.println("获取到的数据："+ name);
        //操作list
        jedis.rpush("list","张三","李四","王五");
        List<String> list = jedis.lrange("list", 0, -1);
        System.out.println("list集合的数据："+ list);


        //5. 关闭jedis
        jedis.close();

    }
}

```

运行效果

![image-20200824120047253](黑马旅游-04.assets/image-20200824120047253.png)

常见错误

![image-20200305154556016](黑马旅游-04.assets/image-20200305154556016.png)

客户端命令查询

![image-20200305154827640](黑马旅游-04.assets/image-20200305154827640.png)

### 小结

* **jedis的作用是什么？**

  - 使用java代码操作redis

* **jedis使用步骤？**

  1. 创建jedis连接池的配置对象

  2. 创建jedis的连接池

  3. 得到jedis

  4. 操作

  5. 关闭jedis

     

## 14.Jedis客户端：工具类优化操作【理解】

### 目标

设计操作连接池与获取连接的工具类



### jedis.properties配置文件内容

```properties
maxWaitMillis=30000
maxTotal=10
host=localhost
port=6379

```

![image-20200824120414121](黑马旅游-04.assets/image-20200824120414121.png) 

### 使用工具类优化连接池操作代码

![image-20200824121251190](黑马旅游-04.assets/image-20200824121251190.png) 

```java
package com.itheima.utils;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

import java.util.ResourceBundle;

/*
该工具类的作用：对外提供jedis
 */
public class JedisUtil {

    private static JedisPool jedisPool ;

    //加载jedis.properties的文件只需要加载一次就够，所以我们把加载配置文件的方法放入静态代码块中
    static{
        //1. 加载jedis.properties
        /*
             加载properties文件有两种方式：
                1. Properties类加载(需要你自己使用类路径得到properties的输入流)
                2. ResourceBundle 加载(底层本身就已经封装好类路径获取properties文件了)
         */
        ResourceBundle resourceBundle = ResourceBundle.getBundle("jedis");//注意：后缀名不能写
        Integer maxWaitMillis = Integer.valueOf(resourceBundle.getString("maxWaitMillis"));
        Integer maxTotal = Integer.valueOf(resourceBundle.getString("maxTotal"));
        Integer port = Integer.valueOf(resourceBundle.getString("port"));
        String host = resourceBundle.getString("host");

        //2.创建jedis连接池配置对象
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);
        jedisPoolConfig.setMaxTotal(maxTotal);

        //3.创建jedis的连接池
         jedisPool = new JedisPool(jedisPoolConfig,host,port);
    }


    public static Jedis getJedis(){
        return jedisPool.getResource();
    }
    
}

```



### 小结

* 使用工具类优化连接池操作有什么好处？

  解决代码的冗余

## 15.Redis面试题1：数据类型与持久化【应用】



**请说出redis常用的数据类型介绍?**

- string
- hash
- list
- set
- zset 



**redis的持久化机制介绍**

有2种持久化策略

RDB策略介绍

> 是redis默认开始的持久化策略,  又叫快照策略,  在符合持久化条件时会将这一时刻内存全部数据写入磁盘文件dump.rdb中（覆盖方式）;

AOF策略介绍

> 是追加方式持久化策略, 默认是没有开启 ,  开启后默认每秒将1秒内的增删改的命令追加到appendonly.aof文件中;			



## 16.Redis面试题2：redis的应用场景【理解】

### 应用场景1：缓存【重点】

![image-20200824123521672](黑马旅游-04.assets/image-20200824123521672.png)

适合作为缓存数据的特点： 数据量少，增删改的频率低，查询频率要高，并发量高



### 应用场景2：秒杀

数据操作特点：增删改的频率高

![image-20200811023404554](黑马旅游-04.assets/image-20200811023404554.png)

### 应用场景3：微博热搜

![image-20200811025615649](黑马旅游-04.assets/image-20200811025615649.png)

### 应用场景4：分布式session

![image-20200811025636476](黑马旅游-04.assets/image-20200811025636476.png)

### 应用场景5：验证码存储【重点】

![image-20200811025814372](黑马旅游-04.assets/image-20200811025814372.png)

## 17.redis缓存应用：导航分类后端【应用】

### 目标

使用redis缓存实现导航分类列表数据展现



### 需求

异步展现导航分类列表数据，并且使用缓存

### 效果

![image-20200811215247641](黑马旅游-04.assets/image-20200811215247641.png)

### 实现步骤

 ![image-20200824154600364](黑马旅游-04.assets/image-20200824154600364.png)

### 代码实现

#### CategoryDao

```java
package com.itheima.dao;

import com.itheima.domain.Category;
import org.apache.ibatis.annotations.Select;

import java.util.List;

public interface CategoryDao {

    //查找所有的旅游路线类别
    @Select("select * from tab_category")
    List<Category> findAll();
}

```

#### CategoryService

```java
package com.itheima.service;

import com.itheima.domain.Category;

import java.util.List;

/**
 * @author 黑马程序员
 */
public interface CategoryService {

    /**
     * 查询所有类别列表数据
     * @return List<Category>
     */
    List<Category> findAll() throws Exception;
}

```

#### CategoryServiceImpl

> //查询所有类别列表数据
> public List<Category> findAll(){
>    //1.查询redis里面存储的类别列表数据返回json字符串数据
>    //2.判断json字符串是否有数据
>    //3.如果json字符串数据无效，调用数据库获取，并写入缓存
>    //4.如果json字符串数据有效，将json字符串转换为java对象返回
>
> }

```java
package com.itheima.service.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.itheima.dao.CategoryDao;
import com.itheima.domain.Category;
import com.itheima.service.CategoryService;
import com.itheima.utils.DaoFactory;
import com.itheima.utils.JedisUtil;
import redis.clients.jedis.Jedis;

import java.io.IOException;
import java.util.List;

public class CategoryServiceImpl implements CategoryService {

    private CategoryDao categoryDao = (CategoryDao) DaoFactory.getDaoInstance(CategoryDao.class);

    @Override
    public List<Category> findAll() {
        //1. 得到jedis
        Jedis jedis = JedisUtil.getJedis();
        //2. 从jedis中查找类别信息
        String categoryListJson = jedis.get("categoryList");
        List<Category> categoryList = null;
        try {
            if(categoryListJson==null){
                //3. 如果redis中不存在类别信息,直接从数据库中查找，然后转换json存储到redis数据库中
                categoryList = categoryDao.findAll();
                //转换为json
                categoryListJson = new ObjectMapper().writeValueAsString(categoryList);
                jedis.set("categoryList",categoryListJson);
            }else {
                //4. 如果存在，转换为List对象返回.
                categoryList = new ObjectMapper().readValue(categoryListJson,List.class);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //5. 关闭jedis
            jedis.close();
        }
        return categoryList;
    }
}

```

#### beans.xml配置

> CategoryService接口与实现类

```xml
<?xml version="1.0" encoding="utf-8"?>
<beans>
    <bean id="userService" class="com.itheima.service.impl.UserServiceImpl"/>
    <bean id="addressService" class="com.itheima.service.impl.AddressServiceImpl"/>
    <bean id="categoryService" class="com.itheima.service.impl.CategoryServiceImpl"/>
</beans>
```

#### CategoryServlet

```java
package com.itheima.web;

import com.itheima.domain.Category;
import com.itheima.service.CategoryService;
import com.itheima.utils.BeanFactory;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

@WebServlet("/categoryServlet")
public class CategoryServlet extends BaseServlet {

    private CategoryService categoryService = (CategoryService) BeanFactory.getBean("categoryService");


    protected void findAll(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        List<Category> categoryList = categoryService.findAll();
        //把集合转换为json写出
        toJsonString(response,categoryList);
    }


}
```

### 小结

java如何操作缓存数据

1.先查询缓存是否有数据
2.没有数据调用dao数据库获取，之后写入缓存

3.以后都从缓存获取数据



## 18.redis缓存应用：导航分类前端【应用】

### 目标

前端发送异步请求获取导航分类列表数据更新到页面上



### 实现步骤

![1603859429275](黑马旅游-04.assets/1603859429275.png)

### header.jsp代码

```jsp
<!-- 首页导航 -->
<div class="navitem">
    <ul class="nav" id="categoryUI">
       <%-- <li class="nav-active"><a href="index.jsp">首页</a></li>
        <li><a href="route_list.jsp">门票</a></li>
        <li><a href="route_list.jsp">酒店</a></li>
        <li><a href="route_list.jsp">香港车票</a></li>
        <li><a href="route_list.jsp">出境游</a></li>
        <li><a href="route_list.jsp">国内游</a></li>
        <li><a href="route_list.jsp">港澳游</a></li>
        <li><a href="route_list.jsp">抱团定制</a></li>
        <li><a href="route_list.jsp">全球自由行</a></li>
        <li><a href="favoriterank.jsp">收藏排行榜</a></li>--%>
    </ul>
</div>
<script type="text/javascript">
      $(function(){
        //1. 发出ajax请求，获取到旅游路线类别信息
        $.ajax({
            url:"${ctx}/categoryServlet",
            data:{"action":"findAll"},
            method:"get",
            success:function(categoryList){
                //每一个类别就是一个li标签
                //1. 定义一个变量保存ul标签的标签内容
                var resultHtml='<li class="nav-active"><a href="index.jsp">首页</a></li>';
                for(var category of categoryList){
                    resultHtml+=' <li><a href="route_list.jsp">'+category.cname+'</a></li>';
                }
                resultHtml+='<li><a href="favoriterank.jsp">收藏排行榜</a></li>';
                //把拼接字符串内容放入categoryUI里面
                $("#categoryUI").html(resultHtml);
            }
        });
    });

</script>
```

### 小结

java中如何使用redis缓存数据？

> 

什么样的数据适合缓存？

> 

