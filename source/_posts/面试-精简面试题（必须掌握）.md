---
title: 面试-精简面试题（必须掌握）
tags:
  - 笔记
  - 面试
  - 面试题
categories:
  - 面试
abbrlink: 56862
date: 2021-01-13 15:28:40
---



## springcloud常用组件

### Eureka

服务注册中心，服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。同时，服务提供方与Eureka之间通过 “心跳” 机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 

### Gateway

Gateway组件的核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发（路由）到对应的微服务。 Spring Cloud Gateway是加在整个微服务最前面的防火墙和代理器，隐藏微服务节点IP与端口信息，从而达到保护微服务的目的。

### Ribbon

负载均衡

### Feign

Feign存在的目的就是为了简化微服务之间的调用

### Hystrix

用于隔离访问远程服务、第三方库，防止出现级联失败。

作用：**防止雪崩**

## springmvc和springboot的关系

Spring包含了SpringMVC，而SpringBoot又包含了Spring或者说是在Spring的基础上做得一个扩展。

spring boot 我理解就是把 spring spring mvc spring data jpa  等等的一些常用的常用的基础框架组合起来，提供默认的配置，然后提供可插拔的设计，就是各种 starter  ，来方便开发者使用这一系列的技术

## 谈谈对spring的理解

Spring是一个开源容器框架，可以接管web层，业务层，dao层，持久层的组件，并且可以配置各种bean,和维护bean与bean之间的关系。其核心就是控制反转(IOC),和面向切面(AOP),简单的说就是一个分层的轻量级开源框架。

## spring的ioc、di、aop分别是什么，ioc和di有什么关系

spring的核心 ioc(控制反转)、di(依赖注入)、aop(面向切面编程)

di与ioc区别是

di做注入,ioc是创建对象

“依赖注入”，相对IOC而言，“依赖注入”明确描述了“被注入对象依赖IOC容器配置依赖对象”。

## 什么是事务

事务就会保证数据的一致性

## 事务的四大特性和隔离级别

### 事务的四大特性(ACID)

| 事务特性              | 含义                                                         |
| --------------------- | ------------------------------------------------------------ |
| 原子性（Atomicity）   | 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 |
| 一致性（Consistency） | 事务前后数据的完整性必须保持一致。                           |
| 隔离性（Isolation）   | 是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离，不能相互影响。 |
| 持久性（Durability）  | 指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。 |

### 事务的隔离级别

| 级别 | 名字     | 隔离级别         | 脏读 | 不可重复读 | 幻读 | 数据库默认隔离级别 |
| ---- | -------- | ---------------- | ---- | ---------- | ---- | ------------------ |
| 1    | 读未提交 | read uncommitted | 是   | 是         | 是   |                    |
| 2    | 读已提交 | read committed   | 否   | 是         | 是   | Oracle和SQL Server |
| 3    | 可重复读 | repeatable read  | 否   | 否         | 是   | MySQL              |
| 4    | 串行化   | serializable     | 否   | 否         | 否   |                    |

## 悲观锁和乐观锁的区别和应用场景

悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）。

相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库 性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。 而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如 果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据

![image-20210115202149587](面试-精简面试题（必须掌握）.assets/image-20210115202149587.png)

## redis的数据类型，持久化方式

字符串类型(String)

列表类型(List)

集合(Set)

 zset（有序集合）

哈希(Hash)

### **RDB（快照）**

　　　　**全量同步：从服务器有的数据全部丢弃，主服务器把所有数据发给他。**

　　　　redis把磁盘中原有数据全部丢弃，然后把redis内存中数据全部重新写入磁盘

　　　　**缺点：**

　　　　　　会丢失数据（当磁盘数据丢弃，正在写入时如果出现故障会导致数据丢失）

　　　　**优点：**

　　　　　　整个Redis数据库将只包含一个文件，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。

　　　　　　性能最大化，它仅需要fork出子进程，由子进程完成持久化工作，极大的避免服务进程执行IO操作了。

### **AOF**

　　　　**增量同步：主服务器只发送从服务器缺少的数据。**

　　　　把所有的修改操作先写入日志中，然后逐条的执行最后就写入磁盘

　　　　**缺点：**

​						对于相同数量的数据集而言，AOF文件通常要大于RDB文件，RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
​						AOF在运行效率上往往会慢于RDB
　　　　**优点：**

​						数据安全性高，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步

### 选择

在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用快照持久化或AOF持久化的一种，或同时开启快照持久化和AOF持久化等。此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机master和从机slave可以独立的选择持久化方案。

（1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。

（2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择快照持久化对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。

## Redis与Memcache

Redis和Memcache是目前非常流行的两种NoSql数据库，读可以用于服务端缓存。两者有怎样的差异呢？

- 从实现来看：
  - redis：单线程
  - Memcache：多线程
- 从存储方式来看：
  - redis：支持数据持久化和主从备份，数据更安全
  - Memcache：数据存于内存，没有持久化功能 
- 从功能来看：
  - redis：除了基本的k-v 结构外，支持多种其它复杂结构、事务等高级功能
  - Memcache：只支持基本k-v 结构
- 从可用性看：
  - redis：支持主从备份、数据分片、哨兵监控
  - memcache：没有分片功能，需要从客户端支持

可以看出，Redis相比Memcache功能更加强大，支持的数据结构也比较丰富，已经不仅仅是一个缓存服务。而Memcache的功能相对单一。

## java的基本数据类型

byte, short, int, long, char, float, double, boolean

## arraylist和linkedlist

ArrayList查询快增删慢，LinkedList增删快，查询慢

## List和Set

list可重复，有序

Set无序不重复

## hashtable和hashmap

#### 共同点:

都是双列集合,底层都是哈希算法

#### 区别:   

1.HashMap是线程不安全的，效率高，JDK1.2版本  

​	Hashtable是线程安全的，效率低，JDK1.0版本

Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步

HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。使用HashMap时就必须要自己增加	同步处理，虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。

2.HashMap可以存储null键和null值

​	Hashtable不可以存储null键和null值

## jvm内存溢出

## jvm调优

## 创建线程的方式

1）继承Thread类创建线程

2）实现Runnable接口创建线程

3）使用Callable和Future创建线程

4）使用线程池例如用Executor框架

## 线程池有几种

Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：

1. `newCachedThreadPool`创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
2. ` newFixedThreadPool `创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
3. `newScheduledThreadPool `创建一个定长线程池，支持定时及周期性任务执行。
4. `newSingleThreadExecutor` 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

## mysql的引擎有几种

### InnoDB存储引擎：

InnoDB支持事务，支持外键，支持行锁，写入数据时操作快

### MyISAM存储引擎

Myisam不支持事务。不支持外键，支持表锁，支持全文索引，读取数据快。

### MEMORY存储引擎

Memory所有的数据都保留在内存中,不需要进行磁盘的IO所以读取的速度很快， 但是一旦关机的话表的结构会保留但是数据就会丢失,表支持Hash索引，因此查找速度很快

## sql优化

## eureka和nacos的区别

## 项目中用到什么设计模式，单例有几种

## SpringMVC的执行流程

1. 一个请求匹配前端控制器 DispatcherServlet 的请求映射路径(在 web.xml中指定), WEB 容器将该请求转交给 DispatcherServlet 处理
2. DispatcherServlet 接收到请求后, 将根据 请求信息 交给 处理器映射器 （HandlerMapping）
3. HandlerMapping 根据用户的url请求 查找匹配该url的 Handler，并返回一个执行链 
4. DispatcherServlet 再请求 处理器适配器(HandlerAdapter) 调用相应的 Handler 进行处理并返回 ModelAndView 给 DispatcherServlet
5. DispatcherServlet 将 ModelAndView 请求 ViewReslover（视图解析器）解析，返回具体 View
6. DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）
7. DispatcherServlet 将页面响应给用户

## mybatis的$和#

#{} : 先使用?占位,后取出参数的值给?赋值,没有SQL注入

​	#{} 如果参数类型是基本数据类型和包装类和String,	#{}里面可以随便写

​    #{} 如果参数是自定义的类,写 #{成员变量}



${} : 直接取出参数的值和SQL语句拼接,会有SQL注入

   ${} 如果参数类型是基本数据类型和包装类和String,     ${} 里面必须写value

   ${} 如果参数是自定义的类,写 ${成员变量}

## mybatis一级缓存和二级缓存的区别

#### 一级缓存概述

一级缓存是 sqlSession 范围的缓存，只能在同一个 sqlSession 内部有效。它本身已经存在，一级缓存不需要手动处理，<font color='red'>**可以直接使用**</font>

#### 二级缓存概述

二级缓存是 mapper 映射级别缓存，作用范围跨越SqlSession，即可以在多个 SqlSession 之间共享二级缓存数据。

## 为什么要用es，es的倒排索引是什么

1、适合海量数据的快速查询

2、方便构建集群  

3、减少数据库压力  

4、es提升数据查询效率，改善用户体验

#### 为什么不直接用Lucene？

- 当多个系统都需要用到搜索的时候，需要单独部署一套，**共用性差**。
- lucene不能做集群，当数据量越来越大，无法动态扩展，**扩展性差**。

#### ElasticSearch对比Solr

Solr利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。

Solr支持更多格式的数据，而Elasticsearch仅支持json文件格式。

Solr官方提供的高级功能更多，例如自带控制台可查询数据，而Elasticsearch更注重于核心功能：索引流程和检索流程。

**Solr在建立索引库时会产生io阻塞，导致查询性能变差，并且随着数据量的增加，Solr的搜索效率会变得更低，而Elasticsearch却没有明显的变化。综上所述，Solr是传统搜索应用的有力解决方案，而Elasticsearch 更适用于实时搜索应用。**

#### 倒排索引

倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引

## rabiitmq的模式有几种

1. 简单模式HelloWorld
2. 工作队列模式Work Queue
3. 发布订阅模式Publish/subscribe,需要设置类型为<font color=red><b>fanout</b></font>的交换机
4. 路由模式Routing，需要设置类型为<font color=red><b>direct</b></font>的交换机
5. 通配符模式Topic，需要设置类型为<font color=red><b>topic</b></font>的交换机

## 单点登录有状态和无状态的区别

### 1）什么是有状态认证？

有状态认证，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如tomcat中的session。

例如登录：用户登录后，我们把登录者的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session。然后下次请求，用户携带cookie值来，我们就能识别到对应session，从而找到用户的信息。

缺点是什么？

- 服务端保存大量数据，增加服务端压力
- 服务端保存用户状态，无法进行水平扩展（无法很好的集群）
- 客户端请求依赖服务端，多次请求必须访问同一台服务器

### 2）什么是无状态认证

微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即：

- 服务端不保存任何客户端请求者信息
- **客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份**

带来的好处是什么呢？

- 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务
- 服务端的集群和状态对客户端透明
- 服务端可以任意的迁移和伸缩
- 减小服务端存储压力

## Shiro原理

![1574048980448](面试-精简面试题（必须掌握）.assets/1574048980448.png)

可以看到：应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject；其每个API的含义：
Subject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；

SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；

Realm：域，Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。
也就是说对于我们而言，最简单的一个Shiro应用：
	1、应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；
	2、我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。
从以上也可以看出，Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。

## 双亲委派机制

## spring中@Autowired和@Resource的区别

历史：@Autowired是属于spring注解，org.springframework.beans.factory.annotation.Autowired

​      @Resource 不属于Spring的注解，jdk1.6支持的注解  javax.annotation.Resource

共同点：

   装备bean，写在字段上，或写在setter方法

不同点：

   @Autowired 默认按类型装备

​      依赖对象必须存在，如果允许null值，可以设置它的required属性为false   @Autowired(required=false)

也可以使用名称装配，配合@Qualifire 注解

```java
public  class  TestServiceImpl{

   @Autowired
   @Qualifier("userDao")
   private UserDao userDao;

}
```

@Resource 默认按名称进行装备，通过name属性进行指定

```java
public class TestServiceImpl{

   //下面两种@Resource只使用一种即可
   @Resource(name="userDao")
   private UserDao userDao; //用于字段上
   
   @Resource(name="userDao")
   public void setUserDao(UserDao userDao){
   //用于属性的setter方法上
   this.userDao=userDao;

  }

}
```

## mysql底层数据结构

## BTree和B+Treee的区别

### 为什么说B+树比B树更适合数据库索引？

1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

## hash的实现原理

哈希表(散列表)通过将关键码映射到表中的某个位置上来存储元素，然后根据关键码来访问元素

常用的hash函数有除留余数法，线性探测，二次探测，开链法，在大部分情况下基本就是用开链法

## Springboot优缺点？

```txt
SpringBoot框架: 可以让我们快速构建企业级Spring应用，简化配置、提高开发效率。

优点:
 - 无需Spring配置文件。
 - 简化Maven依赖配置，排除jar包冲突。
 - 自动完成Spring与框架整合，并且提供默认的配置。
 - 内嵌web容器: tomcat、jetty、undertow。
 - 自带应用监控。
 - 支持热部署，提升开发效率。
  
缺点:
 - 集成度较高，使用过程中不太容易了解底层。
```

## Springboot自动装配原理？

springboot在启动过程当中，会加载项目中所有的META-INF/Spring.factories文件，文件中包含了很多自动配置类，类上面都有一个@Configuration注解，标识它是一个配置类，还有一个条件注解@ConditionalOnClass，必须满足条件注解，配置类才会生效，加入一个相关的启动器依赖，能够使得条件注解生效，配置类也就生效了。

## Springcloud 和 dubbo区别？

```txt
两个没什么关联，如果要说区别，有以下几点:

1. 通信方式不同: Dubbo使用的是RPC通信，Spring Cloud使用的是HTTP方式通信。
  - Dubbo底层使用Netty这样的NIO框架，基于TCP协议传输，配合Hession序列化完成RPC通信。
  - SpringCloud基于Http协议+Rest接口远程调用的通信，相对来说，Http请求会有更大的报文，
    占的带宽也会更多。但是REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，
    不存在代码级别的强依赖，在微服务环境下，显得更为合适。
  
2. 组成部分不同:
   - Dubbo是SOA时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。
   - Spring Cloud诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了Spirng、
     Spirng Boot的优势之上。
   - 两个框架在开始目标就不一致，Dubbo定位服务治理、Spirng Cloud是一套完整的微服务框架。
     比如: 网关、配置中心、消息总线。
```

## 微服务之间是如何独立通讯的？

```txt
1. 可以通过RestTemplate实现微服务调用。
2. 可以通过Feign客户端实现微服务调用。
```

## 什么是服务熔断？什么是服务降级？

```txt
1. 服务降级与服务熔断: 是为了防止调用微服务出现级联失败而引发的雪崩问题。
2. 先服务降级，当降级次数过多才会触发服务熔断。

3. 服务降级: 当调用某个微服务出现不可用或响应时间太长时，就需要进行服务降级，
   快速返回“错误”的响应信息。

4. 服务熔断: 当调用某个微服务总是出现服务降级，这个时候有可能触发服务熔断。
   在Spring Cloud框架中熔断机制是通过Hystrix实现，Hystrix会监控微服务间的调用状况，
   当失败的调用达到一定阈值，默认是5秒内调用20次，失败占比50%，就会启动熔断机制。
```

## SpringBoot和SpringCloud的区别？

```txt
SpringBoot: 是一个快速构建Spring应用的框架，通过starter启动器，帮助我们快速整合第三方常用框架，简化XML配置，提升开发效率。

SpringCloud: 是一套完整的微服务框架，它是一系列框架的集合。它是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过SpringBoot进行再次封装屏蔽掉了复杂的配置和整合，最终给开发者留出了一套简单易懂、易部署的开发工具包。如服务注册发现、配置中心、消息总线、负载均衡、断路器等。

SpringBoot和SpringCloud的区别
- SpringBoot只是一个快速构建Spring应用的框架，算不上微服务框架。
- SpringCloud是一系列框架的集合，基于SpringBoot实现。
```

## 什么是Hystrix？它如何实现容错？

```txt
Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。

Hystrix实现服务容错的手段是: 服务降级与服务熔断。
```

## 如何保证消息一致性？

```txt
在分布式系统中，消息生产与消息消费一致性问题？
解决方案1: 采用有事务消息的中间件(RocketMQ)。

解决方案2: 采用没有事务消息的中间件(RabbitMQ、ActiveMQ)
	消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。
```

## 如何防止消息重复消费？

```txt
生产者重复发送消息到MQ中间件的时候，消费者如何防止消息重复消费的问题?

消费者消费消息时需要采用幂等性:
- 解决方案1: 采用数据库去重，某个列使用Message的id做唯一索引。
- 解决方案2: 采用Redis加锁(setNX)，使用Message的id做为key，在消费之前判断setNX(key)，
  如果没有操作过就消费，否则忽略。
```

## RabbitMQ项目中的实际应用场景，需要注意什么？

```txt
RabbitMQ在项目中主要解决应用解耦，异步消息，流量削锋等问题(写多读少的业务场景都会用到)。 
比如: 秒杀下单、分布式系统数据同步、短信发送等。
注意问题:
-- 消息可靠生产
-- 消息可靠消费
-- 防止消息重复消费
-- 防止消息积压
-- 防止消息丢失
```

## 如何保证redis和数据库的数据一致性



- 更新的时候，**先删除缓存，然后再更新数据库**。
- 读的时候，先读缓存；如果没有的话，就读数据库，同时将数据放入缓存，并返回响应。



## SQL调优

① 使用group by 分组查询是，默认分组后，还会排序，可能会降低速度，

在group by 后面增加 order by null 就可以防止排序.

explain select * from emp group by deptno order by null;

② 有些情况下，可以使用连接来替代子查询。因为使用join，MySQL不需要在内存中创建临时表。

select * from dept, emp where dept.deptno=emp.deptno; [简单处理方式]

select * from dept left join emp on dept.deptno=emp.deptno; [左外连接，更ok!]

③ 对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引

应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：

select id from t where num is null

最好不要给数据库留 NULL，尽可能的使用 NOT NULL 填充数据库.

备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用 NULL。

不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL 也包含在内），都是占用 100 个字符的空间的，如果是 varchar 这样的变长字段， null 不占用空间。

可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：

select id from t where num = 0



## Mybatis是如何防止sql注入？

MyBatis是如何做到SQL预编译的呢？其实在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译。



## nginx有什么作用



反向代理 负载均衡 页面静态服务器

## mybatis和Hibernate有什么区别？

（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。

（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。

（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。

## 什么是索引

索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。如果表有1000个记录，通过索引查找记录至少要比顺序扫描记录快100倍。

### 创建主键索引

主键是一种唯一性索引，当一张表，把某个列设为主键的时候，则该列就是主键索引

### 普通索引

 普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREcolumn=）或排序条件（ORDERBYcolumn）中的数据列创建索引

### 唯一索引

这种索引和前面的“普通索引”基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一

## 索引的实现原理

![img](面试-精简面试题（必须掌握）.assets/clip_image002.jpg)

![img](面试-精简面试题（必须掌握）.assets/clip_image004.jpg)

**数据库索引**，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。**索引的实现通常使用 B 树及其变种 B+ 树**。

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。

## 那些列上适合添加索引

总结:满处一下条件的字段，才应该创建索引

① 肯定在where条件经常使用

② 该字段的内容不是唯一的几个值

③ 字段内容不是频繁变化

```
1.确定针对该表的操作是大量的查询操作还是大量的增删改操作。 

2.尝试建立索引来帮助特定的查询。检查自己的sql语句，为那些频繁在where子句中出现的字段建立索引。 

3.尝试建立复合索引来进一步提高系统性能。修改复合索引将消耗更长时间，同时，复合索引也占磁盘空间。 

4.对于小型的表，建立索引可能会影响性能 

5.应该避免对具有较少值的字段进行索引。 

6.避免选择大型数据类型的列作为索引。 
```



## 如何实现 Spring Boot 应用程序的安全性？ 

为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展 WebSecurityConfigurerAdapter 并覆盖其方法

## Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?

Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。
 Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar  包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes  目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个  jar ，一个可执行，一个可引用。



## 内连接和外连接

#### 内连接效果

![1568680722435](面试-精简面试题（必须掌握）.assets/1568680722435.png)

#### 隐式内连接

隐式内连接：看不到`JOIN`关键字，条件使用`WHERE`指定

```sql
SELECT * FROM 表1, 表2 WHERE 条件;
```

#### 显式内连接

显式内连接：使用`INNER JOIN ... ON`语句, 可以省略`INNER`

```sql
SELECT * FROM 表1 INNER JOIN 表2 ON 表连接条件 WHERE 查询条件;
```



### 左外连接

左外连接：使用`LEFT OUTER JOIN ... ON`，`OUTER`可以省略

```sql
SELECT * FROM 左表 LEFT OUTER JOIN 右表 ON 表连接条件 WHERE 查询条件;
```

**左外连接**可以理解为：**将满足要求的数据显示,左表不满足要求的数据也显示**(保证左表的数据全部显示)

![1568680825033](面试-精简面试题（必须掌握）.assets/1568680825033.png)

## 项目中哪些地方用到redis了

1、redis 5种数据类型介绍 key-value
		String类型
		hash类型  key:value
		list类型  两端链接  有序且可以重复
		set类型   无效且不可重复
		sortedset类型  zset  有序且不可重复		

2、redis持久化机制
	RDB  设置持久化的频率
		弊端：可能造成数据丢失
	AOF  默认：不开启AOF，如果开启，默认每秒持久化一次  最好配置成：基于操作（增删改）持久化
		弊端：执行效率低

3、使用的是SpringDataRedis

4、应用在 

（1）注册时发短信存放验证码  

（2）购物车：用户登录时购物车数据存储到redis中  

（3）退出登录时存放黑名单数据 （失效的token）

（4）支付时存储用来生成二维码的url

## 数据怎么做校验的

1、页面上肯定做校验

2、后台使用Hibernate-Validator框架完成数据校验使用方式主要是注解

   比如：

 第一步：在需要验证的属性上添加注解

```java
@Pattern(regexp = RegexPatterns.USERNAME_REGEX,message = "用户名不正确")
private String username;
@Length(min = 4,max = 30,message = "密码格式不正确")
private String password;
@Pattern(regexp = RegexPatterns.PHONE_REGEX,message = "手机号格式不正确")
private String phone;
```

第二步、在操作controller中只需要给操作对象参数添加 @Valid注解即可

```java
例如：
@PostMapping("register")
public ResponseEntity<Void> register(@Valid User user, @RequestParam("code") String code)
```

## Rabbitmq集群高可用部署

rabbitmq有3种模式，但集群模式是2种

1. 单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。
2. 普通模式：默认的集群模式，某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。
3. 镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案

## Mysql执行计划

### 执行计划的 select_type

查询的类型，主要是用于区分普通查询、联合查询、子查询等。

- **SIMPLE**：简单的 select 查询，查询中不包含子查询或者 union
- **PRIMARY**：查询中包含子部分，最外层查询则被标记为 primary
- **SUBQUERY/MATERIALIZED**：SUBQUERY 表示在 select 或 where 列表中包含了子查询，MATERIALIZED**：**表示 where 后面 in 条件的子查询
- **UNION**：表示 union 中的第二个或后面的 select 语句
- **UNION RESULT**：union 的结果

1. explain 结果中的 type 字段，表示（广义）连接类型，它描述了找到所需数据使用的扫描方式；
2. 常见的扫描类型有：system>const>eq_ref>ref>range>index>ALL，其扫描速度由快到慢；
3. 各类扫描类型的要点是：

1. 1. system 最快：不进行磁盘 IO
   2. const：PK 或者 unique 上的等值查询
   3. eq_ref：PK 或者 unique 上的 join 查询，等值匹配，对于前表的每一行，后表只有一行命中
   4. ref：非唯一索引，等值匹配，可能有多行命中
   5. range：索引上的范围扫描，例如：between、in、>
   6. index：索引上的全集扫描，例如：InnoDB 的 count
   7. ALL 最慢：全表扫描

1. 建立正确的索引，非常重要；
2. 使用 explain 了解并优化执行计划，非常重要；

### 执行计划 Extra 

十分重要的额外信息。

- **Using filesort**：MySQL 对数据使用一个外部的文件内容进行了排序，而不是按照表内的索引进行排序读取。
- **Using temporary**：使用临时表保存中间结果，也就是说 MySQL 在对查询结果排序时使用了临时表，常见于order by 或 group by。
- **Using index**：表示 SQL 操作中使用了覆盖索引（Covering Index），避免了访问表的数据行，效率高。
- **Using index condition**：表示 SQL 操作命中了索引，但不是所有的列数据都在索引树上，还需要访问实际的行记录。
- **Using where**：表示 SQL 操作使用了 where 过滤条件。
- **Select tables optimized away**：基于索引优化 MIN/MAX 操作或者 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即可完成优化。
- **Using join buffer (Block Nested Loop)**：表示 SQL 操作使用了关联查询或者子查询，且需要进行嵌套循环计算。

## sql优化

1. 在表中建立索引，优先考虑where.group by使用到的字段。

2. 尽量在字段后面使用模糊查询
3. 尽量不要使用in 和not in，会造成全表扫描
4. 尽量不要使用or
5. 尽量不要在 where 子句中对字段进行表达式操作

## 如果 RabbitMQ 服务器宕机了，消息会丢失吗？

不会丢失，RabbitMQ 服务器支持消息持久化机制，会把消息持久化到硬盘上。

### 如何防止消息丢失

1.消息持久化

2.ACK确认机制

3.设置集群镜像模式

4.消息补偿机制

## CAP定理

- Consistency   一致性
- Availability     可用性
- Partition tolerance   分区容错（容错性）

#### 一致性和可用性的矛盾

一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。

如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性。

如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。

综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性



## MySQL函数

### 聚合函数

sum avg max min count

分组函数

group  by	

## maven的作用

maven是项目管理构建工具

1. jar包的管理【核心功能】

2. 项目管理工具（项目生命周期管理）

3. 创建聚合项目（以后maven高级的时候讲解）

### spring的线程安全问题

> 有状态的bean：对象中有实例变量（成员变量），可以保存数据，是非线程安全的。
>
> 无状态的bean：对象中没有实例变量（成员变量），不能保存数据，可以在多线程环境下共享，是线程安全的。

1. 我们都知道spring中的bean默认都是单例的，ioc容器中一个类只会存在一个实例对象。这种设计是怎么保证线程安全的？

   一般不会出现线程安全问题。在spring中，绝大部分bean都是无状态的，因此即使这些bean默认是单例的，也不会出现线程安全问题的。比如controller、service、dao这些类，这些类里面通常不会含有成员变量，因此它们被设计成单例的。如果这些类中定义了实例变量，就线程不安全了，所以尽量避免定义实例变量。

2. 对于spring中有状态的bean，比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder，为什么也能够设计成单例的呢？它是怎么保证线程安全的？

   对于有状态的bean，spring采用ThreadLocal进行处理，使它们成为线程安全可以共享的对象。

   对于有状态的bean，也可以使用原型模式（**prototype**），每次使用时都会重新生成一个对象，解决了线程不安全的问题。

   ps：无状态的Bean适合使用不变模式，即单例模式，这样可以共享实例，提高性能。有状态的Bean，多线程环境下不安全，适合使用Prototype原型模式。Prototype: 每次对bean的请求都会创建一个新的bean实例。

## ThreadLocal

ThreadLocal为变量在每个线程中都创建了一个副本，每个线程可以访问自己内部的副本变量