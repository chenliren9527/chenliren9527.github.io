---
title: 乐优电商(0)-乐优商城项目知识点总结
tags:
  - 笔记
  - 项目实战二
  - springcloud
  - 微服务
  - 面试
  - 总结
categories: 
  - 项目实战二
date: 2020-12-24 02:12:34
---

# 1、项目怎么应对高并发

部署层面：分布式集群部署 

架构层面：分布式架构  dubbo+zookeeper或者springboot+springcloud   根据业务对项目进行拆分部署。 多台服务器做不同的事情，使用rabbitMQ做服务之间的通信

数据层面：数据库采用分库分表，常备查询的字段创建索引，使用redis缓存数据，高频查询的并且复杂的数据使用elasticSearch

页面层面：静态页面  



# 2、前后端分离开发，提供一个方法需要知道什么？

编写一个controller的方法一般需要知道四个内容：

  - 请求方式：决定我们用GetMapping还是PostMapping
  - 请求路径：决定映射路径
  - 请求参数：决定方法的参数
  - 返回值结果：决定方法的返回值



# 3、项目中怎么解决跨域的

 首先你要知道什么是跨域，引起跨域的原因，

发起的ajax异步请求+域名不一样，

使用CORS方式解决，在网关处解决的。

# 4、前后端完全分离，前端有没有使用框架？

   后台管理项目的前端用的是vuetify，门户项目是美工做的页面，使用的VUE和后台交互的。

# 5、图片上传怎么做的

 首先，图片是上传到了阿里云，使用的是阿里云前端直传的方式，页面直传需要后台提供一个签名，签名相关的代码用的是阿里提供的。



# 6、spu与sku概念简介

​	spu：标准产品单位  华为mate20  一组商品集合
​	sku：库存量单位 黑色、128G、4G(全网通) 华为mate20  具体到的某款商品

# 7、添加商品涉及到哪些表

大概品牌表、分类表、规格表（规格组合规格菜蔬）、spu表和sku表

# 8、ES索引库中存放的是什么数据，

结合spu和sku表重新组装了商品数据，大概字段有： spu的id、副标题、skus的列表数据（json字符串）、商品名称+分类名称+品牌名称、规格



# 9、ES中对中文怎么处理

使用了ik_max_word分词器



# 10、简单描述一下搜索的步骤（过程）

1. 首先会把商品数据一次性初始化索引数据 

2. 如果有商品上下架，通过mq做索引数据的更新

3. 搜索页中的数据主要有有基本查询和过滤查询两个方法提供具体方法的步骤：
   1. 构建原生查询构建器  NativeSearchQueryBuilder
   2. 控制过滤字段数据  FetchSourceFilter
   3. 搜索和过滤
   4. 分页
   5. 执行查询
   6. 解析结果，封装并返回

4. 注意：当没有输入搜索关键字时，就不查询了



# 11、ES查询方式有哪些



term（词条）查询  

通配符查询 wildcard

模糊查询（容错） fuzzy

区间查询 range

组合查询 bool

分词查询 match



# 12、为什么使用es?

1、适合海量数据的快速查询

2、方便构建集群  

3、减少数据库压力  

4、es提升数据查询效率，改善用户体验



# 13、怎么做页面静态化的

使用thymeleaf技术，模板+数据+thymeleaf的语法=页面



# 14、项目中那些地方用到了页面静态化技术

1、商品静态页面

2、网站首页

3、一些广告活动页面等



# 15、查看RabbitMq的几种消息模型

1、基本消息模式  一个生产者，一个消费者

2、work消息模式   一个生产者，可以有多个消费者

3、订阅模型-Fanout  Fanout，也称为广播。 发送消息要指定一个交换机，被多个消费者消费

4、订阅模型-Direct 定向发送  发送消息要指定一个交换机，消费者可以设置RoutingKey的规则用来绑定队列和交换机的关系

5、订阅模型-Topic  与Direct相比，RoutingKey可以使用通配符

# 16、项目中怎么使用RabbitMQ的

1、技术上：使用springAmqp框架

2、应用上：（1）商品下架时同步索引、静态页 （2）用户注册时发送短信





# 17、项目中哪些地方用到redis了

1、redis 5种数据类型介绍 key-value
		String类型
		hash类型  key:value
		list类型  两端链接  有序且可以重复
		set类型   无效且不可重复
		sortedset类型  zset  有序且不可重复		

2、redis持久化机制
	RDB  设置持久化的频率
		弊端：可能造成数据丢失
	AOF  默认：不开启AOF，如果开启，默认每秒持久化一次  最好配置成：基于操作（增删改）持久化
		弊端：执行效率低

3、使用的是SpringDataRedis

4、应用在 

（1）注册时发短信存放验证码  

（2）购物车：用户登录时购物车数据存储到redis中  

（3）退出登录时存放黑名单数据 （失效的token）

（4）支付时存储用来生成二维码的url



# 18、数据怎么做校验的

1、页面上肯定做校验

2、后台使用Hibernate-Validator框架完成数据校验使用方式主要是注解

   比如：

 第一步：在需要验证的属性上添加注解

```java
@Pattern(regexp = RegexPatterns.USERNAME_REGEX,message = "用户名不正确")
private String username;
@Length(min = 4,max = 30,message = "密码格式不正确")
private String password;
@Pattern(regexp = RegexPatterns.PHONE_REGEX,message = "手机号格式不正确")
private String phone;
```

第二步、在操作controller中只需要给操作对象参数添加 @Valid注解即可

```java
例如：
@PostMapping("register")
public ResponseEntity<Void> register(@Valid User user, @RequestParam("code") String code)
```



# 19、你知道什么加密方式或算法

1、MD5 一种非常普通的不可逆的算法

2、MD5Hash  shiro框架提供的，可以自己加盐、也可以自己定加盐的次数

3、Bycrpt加密方式 spring框架提供的 会在明文基础上随机加盐。盐值往往都是随机生成的字符串

4、Base64 可逆的算法

5、RSA 非对称加密算法



# 20、什么是有状态登录和无状态登录

有状态就是用户在登录后会存储session信息，无状态登录就是用户登录后不存储session信息

# 21、怎么做到无状态登录

使用的jwt规范，java web token

jwt规定生成token字符串的规则，包括
		Header：头部，通常头部有两部分信息
		Payload：载荷，就是有效数据
		Signature：签名，是整个数据的认证信息
		

# 22、介绍jwt交互流程

授权流程：

- 1、用户请求登录，携带用户名密码到授权中心
- 2、授权中心携带用户名密码，到用户中心查询用户
- 3、查询如果正确，生成token凭证
- 4、返回token给用户，存储到cookie中

鉴权流程：

- 1、用户请求某微服务功能，携带token

- 2、在网关统一校验token

- 3、微服务判断校验结果，成功或失败

- 4、失败则直接返回

- 5、成功则处理业务并返回

  缺点：用户访问我们的网站，一次授权后，以后访问微服务都需要鉴权，那么每次鉴权都需要访问授权中心，
  	一个用户请求，被分解为2次请求才能完成，效率比较低。

# 23、怎么保证token的真实性

采用了非对称加密验签介绍
	原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端

  - 私钥加密，持有私钥或公钥才可以解密
  - 公钥加密，持有私钥才可解密

   基于RSA工具类生成公钥和私钥
	

# 24、有没有用到SpringCloudConfig和SpringCloudBus

这两个肯定需要结合使用的

有用到，因为开发、测试、运行环境用到的配置文件是需要变动的，为了方便切环境使用了SpringCloudConfig配置中心，注解，配置文件我们是存放到了码云上

但是配置文件修改后不能马上生效，所以需要使用SpringCloudBus消息总线



# 25、购物车实现的逻辑

不管用户是否登录，都需要实现加入购物车功能，那么已登录和未登录下，购物车数据应该存放在哪里呢？
未登录
		cookie  大小受限制 4kb ，太小，不考虑

​		localstorage  只能保存字符串  本项目采用的方案  5Mb 

​       清除localStorage中购物车商品时机：当用户登录后，需要合并本地购物车列表到登录后的redis购物车列表中，并删除localStorage购物车列表

已登录
	     redis   基于userId作为key   清除redis中购物车商品时机：将购物车商品提交为订单数据后

实现的逻辑：

 未登录时，都是在前端在控制，我主要说一下登录后添加购物车的逻辑
		1、获取页面提交的参数（商品id、商品数量）
		2、获取当前登录用户
		3、获取hash操作的对象，并判断购物车商品是否存在
		4、如果存在查询并解析购物车对象
		5、重置解析出来的购物车商品数量，并将重置结果写回redis中



# 26、下订单涉及到的表

1、用户的联系地址表

2、订单表

3、订单详情表

4、物流信息表

# 27、有没有涉及到定时任务，怎么做的

有，使用springTask/Schedule做的

场景：1、定时发送推广短信

​           2、定时发送生日祝福

​           3、定时清理无效的订单



# 28、定时清理无效的订单的逻辑

 - 1）设置一个超时时间限制，例如1小时，超过1小时未付款则取消订单
 - 2）查询当前以及超时未支付的订单（状态为1，创建时间是1小时以前）
 - 3）修改这些订单的状态为5，交易取消并关闭
 - 4）查询这些订单对应的商品信息
 - 5）恢复库存

# 29、分布式锁的处理方式

Redission框架实现redis锁



# 30、注册时怎么处理恶意频繁发送验证码

1、验证手机号的格式

2、验证此手机号是否已注册

3、发送验证码，记录此号码的发送次数（一个小时内同一个手机号只能发送3次）





