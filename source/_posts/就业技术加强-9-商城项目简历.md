---
title: 就业技术加强(9)-商城项目简历
tags:
  - 笔记
  - 就业技术加强
  - 简历
  - 面试
  - 商城
categories:
  - 就业技术加强
abbrlink: 64518
date: 2021-02-05 22:09:38
---

## 1. 项目撰写

| 项目名称           | Xxx 商城<br/> \*\*书城、\*\*农贸商城、商贸平台、爱乐买、爱购网、天天购、进<br/>口食品批发网、乐家易商城、酷买网、买多网、邮乐商城… |
| ------------------ | ------------------------------------------------------------ |
| **开发环境与工具** | 操作系统：CentOS7<br/>数据库：mysql/mycat、redis、mongoDB<br/>应用服务器：tomcat、Nginx<br/>开发工具：IDEA/Eclipse/MyEclipse；Edraw Max；Power Designer；<br/>Maven；Git；Navicat |
| **使用技术**       | SpringCloud、FastDFS、SpringSecurity<br/>Spring、Spring Boot、SpringMVC、MyBatis<br/>Jsp、JSTL、jQuery、vue、Bootstrap、json/jsonp、JWT<br/>Lucene、ElasticSearch<br/>Mysql、Redis、MongoDB、Sharding Sphere、MyCat<br/>Maven、Git、Nginx、HttpClient、Spring Task、RabbitMQ、Lua、OpenResty |
| **项目团队组成**   | ---工作在大型开发公司<br/>产品经理：3 人，确定需求以及给出产品原型图。<br/>项目经理：1 人，项目管理。<br/>前端团队：5 人，根据产品经理给出的原型制作静态页面。<br/>后端团队：20 人，实现产品功能。<br/>测试团队：5 人，测试所有的功能。<br/>运维团队：3 人，项目的发布以及维护。（如果上线了的话）<br/>总共人数：看开发的讨论组人数有42 人<br/>---工作在中小型开发公司<br/>产品经理：1 人，确定需求以及给出产品原型图。<br/>项目经理：1 人，项目管理。<br/>前端团队：3 人，根据产品经理给出的原型制作静态页面。<br/>后端团队：8 人，实现产品功能。<br/>测试团队：3 人，测试所有的功能。<br/>运维团队：1 人，项目的维护。（如果上线了的话）<br/>总共人数：看开发的讨论组人数有17 人 |
| 开发时间与计划     | ---------- 二次开发，开发二期项目的话<br/>鉴于同学们往往写1 年多的工作经验；所以项目二（二次开发）在<br/>简历中的时间跨度大概可以到8 个月；周期可以如下分配：<br/>界面设计、美工与数据库、详细设计、优化一期：2 个月<br/>开发：5 个月<br/>测试：1 个月<br/>部署准备、文档、需求变更修改：2 个月<br/>---------- 全新开发<br/>工作经验可以写2 年多；所以项目二（全新开发）在简历中的时间<br/>跨度大概可以到18 个月；周期可以如下分配：<br/>需求分析、界面设计、美工与数据库、详细设计：4 个月<br/>开发：10 个月<br/>测试：2 个月<br/>部署准备、文档、需求变更修改：2 个月 |
| **项目描述**       | 描述1：<br/>\*\*商城是一个B2C 的电子商务网站，主要是方便地区网友们快速、<br/>便捷地找到物美价廉的商品。\*\*商城除了展示各类商品外，同时也<br/>积极与各地区想加入电商的卖家沟通合作，实现商品的更多、更优<br/>质和更快捷的服务和折扣商品。整个网站采用分布式架构设计，其<br/>中构成整个网站的三大类系统包括了运营商后台管理系统、商家后<br/>台管理系统、前台系统。其中前台系统中有：门户系统、搜索系统、<br/>详情系统、秒杀系统、购物车系统、订单系统、单点登录系统、用<br/>户中心系统、帮助中心系统、用户论坛等。<br/><br/>描述2：<br/>\*\*商城打造的是“社区+电商”的模式，用户可在本社区中有自己的<br/>圈子、电商生活购物网站；更贴切本社区用户群体的生活所需。整<br/>个电商网站实现的功能较多；系统采用分布式架构，包括有后台管<br/>理系统、商家后台管理、门户系统、商家门户系统、搜索系统、详<br/>情系统、秒杀系统、购物车系统、订单系统、单点登录系统、用户<br/>中心系统、帮助中心系统、用户论坛等子系统。<br/><br/>描述3：<br/>\*\*商城是xxx 地区为了更好地服务区域城市家庭，提供更加优质的<br/>网购服务的一个家电类（生活类、化妆品类、农产品。。。）B2C<br/>网上商城。整个网站采用分布式架构设计，其中构成整个网站的两<br/>大类前后台系统包括了后台管理系统、前台系统。其中前台系统中<br/>有：门户系统、搜索系统、详情系统、秒杀系统、购物车系统、订<br/>单系统、评论系统、用户中心系统、帮助中心系统、用户论坛等。 |
| **项目职责**       | **组长版本：**<br/>前期需求收集和整理需求文档；辅助系统设计师设计系统原型；配<br/>合美工根据系统原型进行切图；根据需求文档进行详细设计、数据<br/>库设计；编写提供给手机端【选择：认证中心系统、购物车系统、<br/>订单系统、搜索系统、商品详情系统、会员管理系统、评论系统】<br/>的RESTful 接口文档；协调项目组开发人员进行功能模块开发。在系<br/>统功能上开发了后台管理系统的\*\*、前台系统的搜索系统、用户中<br/>心、\*\*，门户系统首页静态化；对接Oauth2.0 用户认证系统，部署<br/>Oauth2.0 用户认证的服务器端和调研分析使用Spring Security 整合<br/>Oauth2.0 及JWT 最终实现整个商城的各个子系统的统一登录认证。<br/>安排测试计划和整合系统的各个功能模块并编写系统相关文档。<br/><br/>**组员版本：**<br/>参与并完善需求、设计文档中负责开发的功能模块的UML 图形和功<br/>能描述、进行数据库设计。在开发阶段按照项目组的要求独立完成<br/>了后台管理系统的\*\*、前台系统的搜索系统、购物车系统、用户中<br/>心系统，帮助中心和商品详情页面静态化；商品详情页面静态过程<br/>中应用异步、高效可持久化消息的RabbitMQ 实现商品数据同步。<br/>在开发以外也协助编写系统相关文档。<br/>具体在项目中负责开发的功能主要有：<br/><br/>**管理后台**：<br/>商品审核、规格管理、品牌管理、分类管理、分类模板管理、内容<br/>管理、优惠管理、活动管理、商家管理、会员管理、帮助管理、反<br/>馈管理、评论管理、支付管理、结算管理、日志管理、论坛管理、<br/>订单管理、秒杀管理、系统配置、统计<br/><br/>商品审核：查询、审核、关闭、删除商家提交的商品，利用RabbitMQ<br/>同步商品到搜索、详情、订单系统<br/>规格管理：对商品的规格及其选项进行管理（尺寸、内存...）<br/>品牌管理：管理商品的所有品牌信息（名称、图标）<br/>分类管理：商品的多级分类信息管理<br/>分类模板管理：对应于不同分类，可以选择的品牌和规格的管理；<br/>从而实现按品牌、规格选项各种维度对于商品的查询提供数据支撑<br/>内容管理：主要管理门户系统首页的所有内容；如各类广告、新闻、<br/>楼层数据<br/>优惠管理：设置商城的优惠规则的管理，对某一时段的某些商品可<br/>以进行折扣优惠策略的设置<br/>活动管理：针对某些品牌特别设置的活动商品管理（商品来自商品<br/>管理），之后这些商品在门户系统一个特别的活动页面展示点击可<br/>以查看详情并购买<br/>商家管理：在商城中入驻的商家（卖家）的管理，主要有查询、审<br/>核、禁用、删除、查询、修改商家信息<br/>会员管理：在商城中注册的购买者（买家）的信息管理，主要有查<br/>询、禁用、修改、审核、导入导出等功能<br/>帮助管理：管理在帮助中心系统中需要展示的信息<br/>反馈管理：管理在帮助中心系统中用户提出的问题的回复处理<br/>评论管理：管理在商品详情页面中用户对于商品的评论信息<br/>支付管理：管理用户微信支付后的订单支付日志信息<br/>结算管理：管理各个商家的销售额及每月的结算金额及其结算日志、<br/>导出管理<br/>日志管理：管理短信发送日志信息<br/>论坛管理：管理在论坛系统中的贴和回复信息<br/>订单管理：管理用户提交的订单和对应的商品、支付状态等信息<br/>秒杀管理：管理秒杀商品（查询、审核）<br/>系统配置：管理微信支付接口的配置信息<br/>统计管理：统计商品分类的销售情况；日、月热门销售商品、好评<br/>商品<br/><br/>--------------------------------------------------------------------<br/>**前台系统：**<br/>门户系统、搜索系统、详情系统、秒杀系统、购物车系统、订单系<br/>统、认证中心系统、用户中心系统、帮助中心系统、用户论坛、评<br/>价系统<br/><br/>门户系统：使用thymeleaf 及Nginx 实现门户系统首页面完全静态化；<br/>具体功能包括：动态导航条、新闻、大广告轮播展示、热门商品列<br/>表、各楼层内容展示；该页的所有数据都来自内容管理模块。<br/><br/>搜索系统：利用ElasticSearch 实现动态搜索整个商城的所有商品；<br/>并且利用ElasticSearch 的分组查询加载商品分类，过滤查询（应用<br/>ElasticSearch 嵌套域对应动态多变的商品规格）实现在关键字的查询<br/>基础上实现按照点击的过滤条件对商品进行过滤与京东、天猫的功<br/>能一致。为了保证高可用性和效率， 个人分析研究搭建了<br/>ElasticSearch 集群（3 台ElasticSearch 服务器集群， 3 个分片，每个<br/>分片2 个副本）<br/><br/>详情系统：商品详情在商品审核之后利用Thymeleaf 模板生成商品<br/>静态页面并结合Nginx 实现商品详情页面静态化；在同步的技术调<br/>研分析中选择了可异步、持久化、重发的RabbitMQ 进行同步信息<br/>的传递并最终实现近实时的商品同步到搜索系统、详情系统等<br/><br/>秒杀系统：为了应付秒杀系统的高并发及实时计算商品库存的需求，<br/>在进入秒杀的时候将全部当下的商品加入redis 保证高效性，并在下<br/>单的时候充分利用redis 的单线程特性，使用其setnx 及setget 方法<br/>自行编写分布式锁对订单生成与商品库存的增减进行锁定解决商品<br/>并发数据一致性问题。由于考虑到redis 的负载问题，也对redis 搭<br/>建了集群（5 个主节点，共10 台redis）保证高可用和效率。在订单<br/>未支付之前秒杀订单都存放在redis 中，微信支付成功后将订单和库<br/>存都同步到mysql 数据库中。对于商品在redis 中的数据同步应用<br/>Spring task 进行定时更新<br/><br/>购物车系统：商城提供用户在登录状态下可以将商品加入购物车；<br/>之后再调用支付系统（微信支付）服务创建微信支付订单生成二维<br/>码，用户扫描二维码后，根据微信支付系统的回调信息实时同步订<br/>单的支付状态。<br/><br/>订单系统：主要提供订单生成、查询服务，在订单的生成、商品库<br/>存的增减时充分利用redis 的单线程特性，使用其setnx 及setget 方<br/>法自行编写分布式锁对订单生成与商品库存的增减进行锁定解决商<br/>品并发数据一致性问题。采用了Seata 分布式事务控制在下单时候<br/>的订单生成、商品库存扣减、用户积分增加的事务保障。<br/><br/>单点登录系统：采用了Spring Security Oauth2.0 + JWT 的方案实现在<br/>各个微服务中的单点登录。搭建了Oauth 认证中心，采用密码模式<br/>实现用户的动态登录并利用私钥签发生成令牌token。在其它微服务<br/>中可以配置为资源服务器角色，在有需要请求获取该服务器资源的<br/>时候需要携带登录认证时的令牌，资源服务器利用公钥校验令牌获<br/>取用户信息，并根据用户的角色权限返回对应的资源。<br/><br/>用户中心系统：用户可以在用户中心系统（我的畅购）中查询订单，<br/>支付订单，发货提醒，确认收货，退货，评价，物流信息跟踪等订<br/>单相关操作；也可以查看收藏商品、我的足迹、收货地址管理、个<br/>人信息设置等。<br/><br/>帮助中心系统：展示畅购商城中的一些常见购物问题，并对这些问<br/>题有对应的说明<br/><br/>评论系统：在商品的详情页面中，可以加载曾经购买过该商品的用<br/>户对应商品的评论信息，这些信息全部都存储到MongoDB，查询时<br/>候再从MongoDB 查询返回提高系统的查询效率。<br/><br/>用户论坛：展示用户在畅购商城的论坛中的帖子，也可以发帖、晒<br/>单、回帖等 |

## 2. 项目面试问题

### 请描述你做的商城项目

\*\*商城是xxxx 公司开发的一个的B2C 的网上商城，我们公司负责整个网站的开
发、运营。在系统中商家可以申请入驻到平台进行商品的销售，会员可以在商城
浏览商品、搜索商品、使用购物车、购买商品下订单，以及参加秒杀团购等各种
活动。网站前台共分为门户、搜索、商品详情页、购物车、秒杀、用户中心、单
点登陆系统、帮助中心、论坛等子系统。我主要负责了后台管理系统的*等模块、
前台系统的\*\*；在开发过程中也对项目中遇到的一些关键技术进行了调研分析与
实现。（如：ElasticSearch 的应用，RabbitMQ 的应用，redis 分布式锁的实现，单
点登录系统的部署）

### 请描述RESTful 是什么

REST 是一种架构风格，其核心是面向资源，REST 专门针对网络应用设计和开发
方式，以降低开发的复杂性，提高系统的可伸缩性。

### 说明MyBaits 与Hibernate 的区别

**Mybatis 优势**
MyBatis 可以进行更为细致的SQL 优化，可以减少查询字段。
MyBatis 容易掌握，而Hibernate 门槛较高。
**Hibernate 优势**
Hibernate 的DAO 层开发比MyBatis 简单，Mybatis 需要维护SQL 和结果映射。
Hibernate 对对象的维护和缓存要比MyBatis 好，对增删改查的对象的维护要方
便。Hibernate 数据库移植性很好，MyBatis 的数据库移植性不好，不同的数据库
需要写不同SQL。Hibernate 有更好的二级缓存机制，可以使用第三方缓存。
MyBatis 本身提供的缓存机制不佳。
MyBatis：小巧、方便、高效、学习简单、半自动、移植性不好
Hibernate：强大、方便、高效、学习复杂、全自动、移植性好

### 为什么要选SSM 这个框架

选择是因为mybatis 更加灵活，动态编写sql 语句，提供xml 标签，支持编写动
态sql，解除sql 与程序代码的耦合，容易上手方便后续开发团队的运维

### 描述各个子系统是如何协调工作的

项目主体部分采用的是Dubbo 面向服务的分布式调度框架，利用Zookeeper 作为
注册中心实现各系统之间服务的调用。
项目主体部分采用的是SpringCloud 微服务框架，利用Eureka、Nacos 作为注册
中心实现各系统之间服务的调用。
另外使用RabbitMQ 实现系统之间异步信息通信。前端跨域调用使用CORS 技术。

### 多台服务器之间的session 是如何共享的

tomcat 可以开启、配置集群实现sessiond 共享；
而在商城项目中如果有需要使用各个子系统都需要共用的数据，使用的是Redis

### 如何保存商品图片

在电商项目中需要保存大量的图片，需要一个独立的图片服务器来保存，而且存
储的容量需要可扩展。并且还需要解决在高并发及高可用的问题。可采用FastDFS
分布式文件系统来保存图片。FastDFS 可以搭建服务器集群，可实现存储空间的
水平扩展、负载均衡以及服务器的高可用问题。

### 静态化实现方案

创建详情系统，此系统的功能就是生成静态化页面，例如商品详情页面静态
化。将此工程独立部署到一个服务器上，页面就生成到当前服务器的磁盘上，并
且此工程监听MQ 的消息，一旦商品在后台工程审核通过后，此工程将接收到消
息并且生成静态页面。在此服务器上安装一个nginx 做为访问静态资源的http 服
务器。

### 为什么要使用MQ；

项目中使用到了RabbitMQ，可以实现系统之间的异步通信和消息的持久化，从
而实现业务的解耦和执行效率的提升。
使用MQ 中间件可以有两种通信方式queue 和topic。Queue 可以实现点到点之
间的通信，可以有多个Producer 也可以有多个Consumer，但是消息只能被一个
Consumer 接收，一旦消息被消费后就没有了。
Topic 可以实现类似广播的通信方式，可以有多个Producer 和多个Consumer，一
旦有Producer 发送消息后，此消息可以被所有Consumer 接收。

### RabbitMQ 应用场景

**应用场景1：**当后台系统对商品数据进行添加、删除、修改后，将会发送一个消
息变化的消息，此消息通过topic 进行通信，有多个消费端，:商品详情页面的静
态页面会重新生成。
**应用场景2：**用户注册时，向用户注册发送短信验证码，采用queue 方式通信。
消费端调用阿里大于短信接口进行短信的发送。
**应用场景3：**搜索系统数据同步；在商品审核、删除后，采用queue 方式通信。
搜索系统获取商品数据并更新到ElasticSearch 中。

### Redis 应用场景

购物车系统的所有数据；
商品价格、库存存储；
用户注册验证码；
秒杀系统的订单

### Redis 是nosql 数据库，是否适合存储大数据

Redis 是nosql 数据库，但是redis 是key-value 形式的nosql 数据库，数据是存储
到内存中的，适合于快速存取一般作为缓存使用。所以不适合于大数据的存储。
并且redis 是单线程的如果某个操作进行大数据的存储的话其他的进程都处于等
待状态，这样就降低了性能。所以在redis 中不适合于大数据的存储。如果是类
似商品评论这样的不是非常重要的大批量数据，可采用mongodb。

### Redis 缓存穿透、雪崩与击穿

**穿透：**用户恶意查询一个数据库一定不存在的数据或者很多缓存中不存在的数
据，由于缓存中没有，所以这些请求都直接去查询数据库了；导致数据库异常<br/>**解决方案：**可以加针对这些key 的分布式锁排队加载数据；或者预先访问并加载，
再加严格的判断；比如不能去查询null 的key。<br/><br/>**雪崩：**缓存在同一时间内大量key 过期（失效被删除），而又有的一大批请求因
为没有找到缓冲而都瞬间都去查找数据库中数据；导致连接异常。<br/>**解决方案：**可以加针对这些key 的分布式锁排队加载数据，或者错开缓存数据的
过期时间<br/><br/>**击穿：**是指一个key 对应的数据被频繁访问，也就是高并发地集中对这一个key
进行访问，当这个key 在失效的瞬间，持续的高并发请求就穿破缓存，直接请求
数据库，就像在一个屏障上凿开了一个洞<br/>**解决方案：**对应击穿加锁无用，因为它就是一个特定的key；那么针对业务重要
或频繁被访问的数据则设置缓存永不过期。

### 请描述你的工作时开发流程；

需求分析——详细设计——数据库设计——编码实现——测试

### 搜索系统是怎么实现的

电商搜索一般也是使用全文检索实现，畅购使用的是ElasticSearch 作为全文检索服
务器，实现搜索功能。在ElasticSearch 中配置跟业务相关的业务域，从数据库中把
相关的数据导入到索引库中。例如商品搜索功能就把商品表中的数据导入到索引
库中。然后使用ElasticSearch 实现商品搜索，然后在页面中把搜索结果展示出来。
我们把SKU 商品名称、商家名称、价格、规格等信息设置为业务域。规格的存储
采用了动态域来实现。

### 项目中遇到了哪些问题

遇到了js 跨域获取后台管理系统的数据问题，最后采用jsonp 的方式解决；
遇到了商品数据如何大批量、不影响性能并异步的通知各个子系统的问题，最后
采样RabbitMQ 解决；
遇到了为了提高数据加载上的问题，最后利用Redis 缓存大部分数据的解决；

### 商品的价格，选择用什么数据类型去存储的，为什么

要选择这种数据类型
使用长整型；更加精准和便于和其它接口进行交互；而且淘宝也是这么做的

### 你遇到最难的技术问题，怎么解决

ElasticSearch 搜索订单数据时，要根据多个查询条件查询数据返回索引数据并再根
据搜索的返回的订单id 再到订单系统查询具体的订单。

### 做过的最自豪的功能

整合Redis 的服务，并编写单机版和集群版的工具类调用Jedis 的接口。
商品更新后同步其它子系统的商品数据上，从无到有的去调研、分析、选择MQ
实现数据的同步，并最后选择了通配符模式精确地通知各个子系统。

### 浏览器禁用cookie 怎么办

系统在设计之初就确定必须要提醒用户开启cookie 的；如果禁用掉以后那么无
法进行正常的单点登录和不能实现未登录下购物车功能的实现。
被禁用cookie 后，我们系统会提示用户开启，若不开启则不可以继续使用系统
就像京东和天猫一样。

### 复制了令牌就可以访问微服务，怎么保证安全

复制了JWT 令牌就可以访问微服务信息，是因为这些服务器都在内网；若是外
部请求访问是不可直接访问这些内网微服务的。外部请求需要先经过Nginx、网
关之后再到第一个微服务。
令牌是有时效的，在时效内可以访问；超时则不可用。

### 商城的支付系统是如何实现的

系统采用微信扫码支付。首先需要到微信平台申请微信公众账号（服务号），然
后再申请开通微信支付。开通后会得到appid、秘钥等数据，用于调用微信支付
接口。
微信支付接口是通过httpClient 方式向微信支付平台发送数据并获取结果。
（1）调用统一下单接口获取url
（2）根据获取的url 在页面上通过qrcode.js 生成二维码
（3）生成二维码后，实时轮询查询订单状态，当返回成功时，跳转至成功页面

### 系统并发情况及如何解决大并发的问题

经过对系统的调优，保证压力测试时每个tomcat 的并发量达到400。现在有
5 台web 服务器提供服务，基本上也就是2000 左右的并发，如果将来并发量进
一步提高是可以再增加服务器来提供并发能力。
解决高并发问题首先要提高本系统的吞吐能力，例如在系统中添加缓存、实
现网页静态化等方式。如果在系统优化之后还不能满足业务的需要就需要增加服
务器，做服务器集群。前端使用nginx 做负载均衡服务器，并实现nginx 的高可
用。目前可以满足当前的业务需要，如果将来业务量增加的话可以考虑添加服务
器及F5 硬负载等设备。

### 项目里什么地方会有高并发？保证高并发、线程安全

首页、详情、购物车、订单；这些存在高并发。AtomicInteger、synchronized、Lock、
ThreadLocal 等类来保证在代码层面上的线程安全；如果是功能上需要自主多线
程处理那么也会使用线程池ThreadPool 来提高并发效率。
对高并发的处理会利用Redis 实现分布式锁(setnx，getset)机制。

### 商品抢购时如何控制库存

在任何进行商品库存相关的代码时候都对代码进行分布式锁锁定。
分布式锁采用redis 的（setNx 和过期时间实现；虽然课上的不是如此而是更好，
但是路人甲能听懂上面的答案。）

### 数据库的数据特别大时如何扩容

数据库可以实现垂直切分和水平节分。垂直切分就是将不同业务模块的表存入到
不同的数据库中。水平切分就是将一个表的数据按照一定分片规则存储在不同的
数据库中。
可以使用mycat 数据库中间件。Mycat 可以很方便地管理数据的集群。通过设置
数据节点、分片规则、逻辑库、逻辑表来实现数据的水平切分。

### MySQL 的优化

使用过解释计划EXPLAIN 、创建索引、不要将%放前面查询才能让索引生效、使
用exist 代替in、配置数据库的缓冲池、最大连接数等配置项。
数据库在使用的时候采用MariaDB、Percona 等高性能的类mysql 或mysql 高性能
分支版本。
数据库海量数据处理使用了mycat 分片分库的方式处理。

### SQL 查询语句的优化

在表中建立索引，优先考虑where、group by 使用到的字段
尽量避免使用in、not in、or、null，会导致数据库引擎放弃索引进行全表扫描
尽量避免使用select *，返回无用的字段会降低查询效率

### 数据库引数据库引擎



![image](就业技术加强-9-商城项目简历.assets/Image_001.jpg)



在 MySQL 中，可以对不同的表使用不同的存储引擎；

InnoDB 存储引擎；事务型数据库的首选引擎，支持事务，支持行锁定和外键。

MyISAM 存储引擎；ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源，但不支持事务处理、不支持外来键、不能够容错、也不支持索引。



MyISAM 支持的是表级锁，而 InnoDB 支持的是行级锁。但由于锁的粒度更小，

写操作不会锁定全表，所以在并发较高时，使用 Innodb 引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围，InnoDB 表同样会锁全表，

例如：update table set columnabc='1' where name like “a%”

### 关于数据库读写分离

使用 Spring Aop 与 Mysql 的主从复制功能实现读写分离。

**读写分离：**将应用程序中对数据库的写的操作是一个数据库；对数据库读取数据的是另外一个数据库。而两个数据库的数据需要保证一致。

在应用程序中，可以使用 spring aop 对将要执行的业务方法的特征进行判断，如：包含 query、find、select 等的操作归类为读数据库的读操作；具体的在 spring的配置文件中可以指定多个读库和写库的数据源 datasource，如果是本次操作是读数据库中数据，那么将本次的持久层操作对象的数据源指定为读库数据源（可以多个）；写操作则指定为写库的数据源（可以多个）。从而达到在应用程序上做到数据库读写分离；减轻数据库访问压力。

为了保证读库和写库的数据的一致；需要在安装 mysql 的时候配置 Mysql 的主从复制功能，从而让多个读写数据库的数据的一致。

### 关于 ElasticSearch 集群

ES 集群架构 6 个节点，索引：5 分片；ES 调优：在设计映射阶段针对数据搜索情况合理设置数据类型，尽可能多的设置 keyword 类型域；根据需要设置不同域的索引、查询分词器；查询时尽可能少使用模糊和相似查询。

如果数据量增长迅速，数据过大如何解决？可以重新创建索引（指定更多的集群节点和分片），然后将原数据导入再次导入。（注意：es 在创建索引后不能直接扩容）



### Redis 原理说明



Redis 有 string、hash、list、set、sorted set 共 5 种数据类型；而 Redis 内部则使

用一个 redisObject 对象（包含类型 type、编码方式 encoding 等属性）来表示所有的 key 和 value；其中类型 type  表示 value 是什么数据类型，编码方式 encoding则是 5 种数据类型在 redis 内部的存储方式。如：type=string 表示 value 是一个普通字符串，对应的 encoding 可以是 raw 或者是 int，如果是 raw 表示存储类型为字符类型，如果是 int 则代表存储类型为数值型类存储。



Redis 有两种主要的持久化方式；分别是 RDB 和 AOF。



RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照， RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。这种文件非常适合用于进行备份；其时间间隔可以通过配置文件配置。Redis 默认使用的持久化是 RDB 方式。



AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF 文件是一个只进行追加操作的日志文件；若说两种方式特点：在恢复速度上来说，RDB 恢复数据集的速度要比 AOF 恢复的速度要快。



### 关于分布式事务的处理

#### 一般事务解决方案：

**两个阶段：**将提交分成两阶段进行的目的很明确，就是尽可能晚地提交事务，让事务在提交前尽可能地完成所有能完成的工作，这样，最后的提交阶段将是一个耗时极短的微小操作，这种操作在一个分布式系统中失败的概率是非常小的

准备阶段：事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交。

提交阶段：如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息。



**一阶段提交(Best Efforts 1PC 模式)：**从应用程序向数据库发出提交请求到数据库完成提交或回滚之后将结果返回给应用程序的过程。



**TCC 编程模式**：也是两阶段提交的一个变种。TCC 提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm 和 Cancel 三个操作。以在线下单为例，Try 阶段会去扣库存，Confirm 阶段则是去更新订单状态，如果更新订单失败，则进入

Cancel 阶段，会去恢复库存。



#### 消息最终一致性分布式事务解决：

在后台管理系统中更新商品后，需要同步搜索系统、详情系统商品信息的话；这时候会发送 MQ 消息，然后在搜索系统、详情系统会订阅消息，接收到消息后执行对应操作。

在后台中管理系统在同一个事务中执行的内容：更新商品数据，发送 MQ 消息；如果更新商品数据失败那么则回滚，并且不会发送 MQ 消息；如果发送 MQ 消息失败，那么也将回滚商品数据的更新。

在搜索系统、详情系统中监听 MQ 消息，执行对应的同步更新操作，如果消息接收失败那么 RabbitMQ 会重新发送 6 次消息，并且做了消息持久化，只要搜索系统、详情系统没有接收消息那么下次则会重发保证消息的成功传递。至于接收到消息后搜索、详情系统的执行失败是不会回滚在后台管理系统的操作的；所以在开发过程中需要保证搜索、详情系统的执行成功率非常高。如果在消息消费方处理失败的话则会再接收到消息的时候已经记录到数据库中；处理失败也不会丢失消息。系统会启动定时任务扫描这张表对未处理的消息进行处理。



或者直接使用 Seata 分布式事务组件。

### Dubbo 执行原理说明

dubbo 有服务提供者、服务消费者、注册中心和监控中心。首先由提供者在一个

Servlet 容器中暴露服务，将服务注册到注册中心（zookeeper/redis 等都可以作为注册中心）；然后由消费方向注册中心订阅服务，当消费方注册的服务存在在注册时注册中心返回服务提供者地址列表给消费者；服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用。服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

### Dubbo 配置调优

1. 根据不同的业务设置不同的超时时间和重试次数；

2. 在 服 务 提 供 方 中 设 置 服 务 的 负 载 均 衡 策 略 以 及 权 重 ； 如 ：

   @Service(loadbalance = "roundrobin",weight = 10)；

3. 集群容错；

4. 灰度发布



### Zookeeper 功能说明

zookeeper 是一个分布式应用程序协调服务；它提供的功能有：命名服务、配置管理、集群管理、分布式锁、队列管理。

**命名服务**：在 zookeeper 的文件系统里创建一个目录可与下游程序约定好路径，通过路径即能互相探索发现。

**配置管理：**在做应用服务器集群的时候；可以将项目修改的配置文件全部放到

zookeeper 上面，保存到 zookeeper 的某个目录节点中，然后相关程序对这个目录节点进行监听，一有配置文件发送变化，那么每个应用程序都将收到通知，然后从 zk 里面获取最新配置文件同步到应用服务器上。

**集群管理：**在应用服务器集群的时候；是否有集群节点加入或退出的时候，

zookeeper 可以感知并通知其它应用服务器知晓当前各个集群节点的在线状态。所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper 的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除。

**分布式锁**：zookeeper 上的一个 znode 看作是一把锁，通过 createznode 的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的 distribute_lock 节点就释放出锁。（关于分布式锁，可以使用 redis 的 setnx 命令来实现也是一种方法）

**队列管理**：第一种同步队列：当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达（在约定目录下创建临时目录节点，监听节点数目是否是要求的数目）。第二种队列按照 FIFO 方式进行入队和出队操作。



### Zookeeper 工作原理

Zookeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。

### Eureka 服务器挂了微服务是否能正常运行

所有微服务都需要注册到 eureka，所以 eureka 挂了后会出现服务无法注册的报错信息；但是并不影响当前系统自身功能的运行。

为了提高 Eureka 微服务的运行稳定性，可以对 eureka 搭建集群。

### 关于项目压力测试

作为开发人员；使用了 jemeter 对主要的子系统进行了压力测试。测试的系统形如：门户系统首页、登录注册、购物车列表页面、订单生成等功能进行了在1 秒内 1000-100000 不同等级的并发线程数测试。

如：前台门户系统在做了静态化的情况下集群 20（2-20 台都可以）台服务器，最大 PV(page view)即页面浏览量为 2 万（2k-2w 都可以）每秒，订单 6000 笔每秒。（订单服务器集群数量为 10 台。）这些的最大并发量的估算以 tomcat 的一台最大并发量 500-2000 算，如果集群 6 台 tomcat；那么大概是 6*500-6*2000，也就是 3000-12000；但是订单操作复杂，所以不可能是到最大可支持的并发的。所以集群 10 台订单服务器，6000/s 订单较合理。

### DUBBO 与 Spring Cloud 区别

两个都是微服务架构框架。

- DUBBO 使用 RPC 协议进行远程服务调用，主要是服务注册发现管理；采用默认的 dubbo 协议通信速度比 spring cloud 快。
- spring cloud 使用 http 协议进行远程服务调用，跨平台性好；有完整的微服务生态组件（服务注册发现 eureka，ribbon 负载均衡，hystrix 服务熔断降级，网关 gateway，配置中心 config，总线 bus，链路追踪 sleuth）,服务调用通信速度要比 dubbo 慢。

#### Nginx 限流

如果在问到电商项目流量过大的问题；那么可以通过配置 nginx 的 ginx

limit_req_zone 和 limit_req 两个指令，限制单个 ip 的请求处理速率。如：可以设置每秒钟只处理 1 个请求，也可以设置一个队列，如队列大小 10；设置之后可以在不延迟请求的情况下 10 个请求处理，处理完一个再空出有队列位置再接受新请求。

如果有服务器要在限流之外，还可以配置 nginx 的白名单；白名单里面的 ip不会受到限制

### 为什么 Nginx 限流后网关还需要限流

Nginx 承载的流量比较大；即使限流之后请求量也还是可能比较大；而后端的服务器或者数据库可承受的流量较有限；所以为了后端服务器组件（系统、数据库及各类中间件）稳定工作；可以在网关中再次限流。

### tomcat 优化

- 设置 catalina.bat 文件中 jvm 的-Xms：虚拟机初始化时的最小堆内存；-Xmx：虚拟机可使用的最大堆内存。
- 修改接收请求的处理方式为 NIO；
- 启用线程池：在 tomcat 中每一个用户请求都是一个线程，可以使用线程池提高性能（maxThreads 可以处理的最大并发请求数,默认 200

minSpareThreads 线程的最小数量始终保持运行,默认 10）



### 商品图片压缩显示问题

如果是商品图片；那么需要在上传的时候将原图进行指定大小的压缩存储；一般会设置如下存储方案：

原图：即不压缩的图片，原本保存到 fastDFS；大图：600\*800 将图片大小压缩并存储；

中图：300\*200

小图：100\*100

这些图片的格式也可现实的终端相关；如果是详情页面可以使用原图、大图，如果是手机可以是中图；如果是在列表上展示可以使用小图。

### Spring Security 与 shiro 区别

#### 相同点：

1. 认证功能
2. 授权功能
3. 加密功能
4. 会话管理
5. 缓存支持

#### 不同点：

Shiro 的配置和使用比较简单，Spring Security 上手复杂

Shiro 依赖性低，不需要任何框架和容器，可以独立运行，而 Spring Security 依赖于 Spring 容器



### 门户网站及其它概念

门户网站：就是一个网站的入口，这个入口页面中会挂载很多其它系统的入口（链接），一般情况下门户网站都实现了单点登录功能；即只需要登录一次访问其它系统时候不需要再次登录。

OA 办公自动化系统

MIS 企业业务系统

CRM 客户关系管理系统

ERP 企业资源管理系统；该系统会包含非常多其它系统，业务复杂庞大

HR 人事管理系统

### 普通商品如何处理瞬时高并发及库存

普通商品若有瞬时并发大的问题，可以在 nginx 配置限流 burst 排队方式避免系统宕机；库存的处理一样可以使用秒杀订单下单时候处理方案，也就是可以使用

分布式锁。

### 如何保障 MQ 消息不丢失

生产者丢失消息：在发送消息的时候可以将消息记录到数据库表，发送失败的消息可以进行重发。

消费者端丢失消息：接收消息启用手动确认机制，真正达到消费端并消费后才向

MQ 发送确认消息；若没有确认消息接收，消息会持久化在 RabbitMQ 中，等待真正被接收。



### MQ 消息中间件异常怎么处理

可以使用ErrorHandler 接口监听@RabbitListener 注解方法中抛出的异常进行异常处理。

1. 记录异常信息到数据库中；

2. 消息不确认，则会再次重发；如果不需要重发那么就记录消息到数据库中返回给 MQ 消息接收成功；然后在使用定时任务处理保存在数据库中的那些消息。

### 项目生产环境问题如何排查

找到对应的应用服务器（tomcat）的日志文件；再根据出现问题的时间点定位到日志文件位置；查看这个时段的异常信息再根据异常信息排查问题。

1、查看分布式日志系统中的异常信息；

2、根据业务操作，到链路追踪系统中查询该业务的链路调用情况；然后进行优化解决问题

### 为什么要手动添加 header 里的 Authorization

在网关中会从请求参数、header、cookie 中获取 Authorization 的值，这个值也就是令牌；在获取到后会传递到其它微服务，实现单点访问。

MQ 如何保障消息可靠生产

1. 把消息数据写入数据库，用状态码来控制消息发送状态。
2. 开启定时任务，间隔 3 秒，查询未发送的消息。
3. 调用消息生产者，发送消息到 MQ 中间件。
4. 消息生产者，设置 confirmCallback 确认回调对象，判断 ack

-- true: 消息发送成功，修改消息发送状态为: 已发送。

-- false: 消息发送失败。



![image](就业技术加强-9-商城项目简历.assets/Image_002.jpg)



### MQ 如何保障消息可靠消费

1. 手动 ACK 确认机制。
2. 防止消息重复消费。
3. 消息重投、拒绝确认的消息，在丢弃之后，需要存入死信队列。
4. 死信队列中的消息还消费失败的话，就需要人为干预或预警。

![image](就业技术加强-9-商城项目简历.assets/Image_003.jpg)



Ack 机制会影响处理效率；可以不管如何都先将消息存入到数据库；然后定时处理这些消息。

### MQ 死信队列

当我们的业务队列处理消息失败(业务异常重试次数达到上限、消息被拒绝、消息过期、队列已满)，就会将这些消息重新投递到一个新的队列，该队列存储的都是处理失败的消息，该队列就叫死信队列 DLQ(Dead Letter Queue)。

- 消息被拒绝 (basic.reject or basic.nack)
- 消息过期 TTL(Time To Live)
- 队列已满



### MQ 如何防止消息重复消费

利用去重表来解决，每次接收到消息之后，先从去重表查询该消息是否已经消费，如果已经消费就不处理本来的业务，否则处理本来的业务并且往去重表添加一行消息去重记录。

### MQ 如何解决消息积压问题

1. 消息过多，消费者消费速度太慢。

   -- 多个消费者并发消费

   -- 多线程并发消费

   -- 设置消息存活时间(TTL) Time To Live

   -- 设置队列中存储消息的界限(Lim) limit

   

2. 消费者消费失败，消息还在业务队列中。

   -- 再重试一次，如果还不行，扔到死信队列，避免队列阻塞。