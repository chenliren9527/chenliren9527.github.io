---
title: 面试-商城项目模块介绍模板
tags:
  - 笔记
  - 面试
categories:
  - 面试
abbrlink: 26569
date: 2021-01-17 00:34:45
---

![个人自我介绍](面试-商城项目模块介绍模板.assets/个人自我介绍.png)

### 自我介绍

​    您好，我叫XXX，湖南人，今年26岁，14年毕业于XXX大学。从15中旬转行做Java开发工作，到现在有两年半的时间。

两年半的java工作，我经历了两家公司。第一家公司OA，CRM，ERP，出纳财务管理，或者可以根据客户要求进行二次开发。做的是一些传统的项目。最近这家公司做的项目是一个B2C的综合性的管材电商管理系统。我就简单介绍一下最近做的整个管材的电商平台。最近做的的，比较熟悉。

这个管材电商管理系统，就是面向于一些管材的商家和消费者、或者说平台的用户之间的一个对接的桥梁。用户可以在商城浏览商品、下订单，以及参加各种活动；商家可以入驻商城，在该平台开店出售自己的商品，并且得到商城提供的可靠服务；而平台的管理员和运营（也就是电商平台内部的的管理人员）可以在平台后台管理商品、订单、会员等。客服可以在后台管理系统中处理用户的询问以及投诉。它是类似于淘宝、京东这样的一个电商平台，不过淘宝、京东是一个特别大的一个平台，各种种类的商品都有。我们这个平台就专注于管材及其附件这一块。

**系统模块：**整个系统采用的是dubbo分布式系统，主要分为以下几个模块：

1、**后台管理系统**：主要实现商品管理、会员管理，CMS内容管理系统、crm客户关系管理、采购管理等。

2、**门户系统（前台系统）**：首页系统，主要是面向用户访问，用户可以在门户系统中进行注册、登录、浏览搜索商品等操作。

3、**单点登录系统**：主要提供之中用户登录凭证的集中解决方案，提供和用户信息相关的接口，比如用户注册、查询等接口。

4、**搜索系统**：提供商品的搜索功能。，采用MQ机制保证商品数据可以及时同步到SOLR中；

5、**订单系统**：提供下单、查询订单、修改订单状态、定时处理订单。

6、**会员系统**：用户可以在该系统中查询已下的订单、收藏的商品、我的优惠券、团购等信息。

7、**支付系统**，主要是负责订单的支付，对账等功能，主要是对接支付宝的接口。

 

我主要负责单点登录、搜索、购物车这三个模块。我就主要给您讲到我所负责的这两块。

 

**首先是单点登录系统**Single Sign On SSO。

SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统；不需要重复、多次、多个系统登录。它可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。

我们怎么做到用户只需要登录一次就可以访问所有相互信任的应用系统、能够得到其他所有系统的信任。我们怎么产生和储存那个信任，再就是其他系统如何验证这个信任的有效性呢。这里我运用的是cookie作为凭证媒介，存储一个登陆的票据，采用jsonp实现跨域登陆，页面重定向实现三位一体的解决方案。

就是我一旦在这个单点登录系统登陆了以后，不管是订单系统，还是一些优惠系统，会员系统，这些它都是可以直接凭借这个ticket做为媒介直接去验证，不用在其他系统进行二次登陆的。

首先登陆后，我们将密码按照原加密方式加密后到数据库里面查询，看是否有与用户输入的密码与用户名匹配的数据。如果有，我们生成一份ticket票据，也就是一个用户的凭证，以ticket加上一个前缀作为key，用户json字符串作为value，存入redis缓存中（redis储存时间设置为1h，且每次查找的时候都再次设置了一次）。并且使用cookie作为媒介，存放用户凭证。将cookie设置为可以跨域请求。cookie过期时间设置方式，会话级cookie，关闭浏览器失效。

用户登录父应用之后，当用户访问子应用的时候，携带上这个cookie，通过JSONP实现跨域支持。验证用户的登录状态，如果通过验证则登录用户。最后通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。

 

**搜索系统**

我们这个我们用的是Solr/Lucene一起去做这一块，解决用户量大，数据量很大，业务系统对查询速度要求高的需求。（实时查询）。其实它的一个底层的原理就是一个反向索引，反向索引就是建立词语与文档的对应关系（词语在什么文档出现，出现了多少次，以及在什么位置出现）。Lucene全文检索就是把原始文档根据一定的规则拆分成若干个关键词，然后根据关键词创建索引，当查询时先查询索引找到对应的关键词，并根据关键词找到对应的文档，也就是查询结果，最终把查询结果展示给用户的过程。（lucene和solr的区别是在于：Solr是基于Lucene开发的全文检索服务器，而Lucene就是一套实现了全文检索的api，其本质就是一个全文检索的过程。）

搜索我们是实现在首页，并不需要显示一个商品的全部数据，我们只需要显示商品的标题、买点、价格、图片，就可以了，所以并不需要将所有字段都同步到索引库里面，方便后续操作，我们还需要用到id，所以只需要标题、买点、价格、图片、id添加到索引库里。查询的时候我们就可以直接到索引库里面查询就可以了。搜索的时候，用户传入关键字，我们将title作为搜索域，进行分页查询，得到我们想要的数据，显示到页面上。然后同时整个的一个电商系统，我们做到的是一个高亮的显示，就是让客户直观的感受到自己所搜索的这些产品。

我们采用MQ机制保证商品数据可以及时同步到SOLR中；在后台管理系统CRUD操作成功，后通知哪些需要知道商品发生了变更的系统，通知这些系统哪个商品做了什么操作，让这些系统自身去更新它该更新的数据。这样系统之间的耦合度就大大降低了。要做得服务器之间这种消息的通知，可以使用消息队列。

 

**购物车**

未登录的情况下，将购物车存在cookie中。登陆的情况下，将购物车存在redis中。判断购物车时候有商品，有这个商品则增加数量，没有商品，则购物车中添加商品。

（ctrun_cart：list<cartItemJson> json格式）。

（hash格式：ctrun_cart_+userid：map<itemId,cartItemJson>）

在商品详情页面中，量通过url路将商品的id和购买的数径传到后台中。通过商品id查询商品信息。并且获得cookie中的用户ticket，即判断用户已经登陆了。

如果用户已经登陆了，通过ticket查询redis缓存里面用户信息。登陆的情况下，将购物车存在redis中。

Redis中我们采用的是hash结构（介绍hash结构），我们是采用一个ctrun_cart_+userId作为key，map里面是用itemId作为 key,商品信息的json字符串cartItemJson作为value。

首先判断redis缓存中是否有这样的key（是否有购物车数据），如果有的话，则通过key和itemId查询相应的cartItemJson。判断是否为null，是否有这个商品，有这个商品则增加数量，修改购物车商品的数量。没有商品，则购物车中添加商品，即将商品封装到购物项中。

如果用户没有登陆则将购物存在cookie中。

首先从cookie中查询购物车。判断是否查到数据。判断是否含有购物车，是否有商品（遍历集合），如果都有则修改购物项的数量和修改更新时间。并且设施一个标志为true。如果没有购物车则创建购物车，有购物车没有购物项，则创建购物项封装数据，存入list集和中（即购物车中）。再将购物车存入cookie中。

添加完后跳转到购物车列表页面cart.jsp。

好几个操作完后都需要跳转到购物车列表页面，所以把跳转到购物车列表页面的方法抽取出来。因为在购物车页面要显示商品，所以，需要将上述储存的商品查询出来，同样需要判断是否登陆，如果已经登陆则到redis缓存中查询，没有登陆从cookie中查询。页面上为了方便显示是遍历list集合，所以我们的查询结果是一个list集合。

修改购物车的数量购物车

购物车加减按钮的操作。每点击一次都会发送一次请求。将商品的itemId和数量带给后台（http://www.ctrun.com/cart/update/1057746/30）。通过票据判断用户是否登陆。修改rendis或者cookie里面购物项的数量。查询购物车，修改数量，再将购物数据存入cookie。

根据itemId删除购物车里面的商品、清空购物车

将需要删除的itemId传入后台，如果登陆了，则删除redis里面的相应的商品购物项。如果没有登陆，则将cookie中的购物车查询出来，删除cookie中的相应的商品购物项。Cookie中删除后需要判断list集合中（购物车）是否还有商品，如果没有则将cookie直接删除，如果有则再次存入cookie中。

登陆后，将cookie中的购物车商品合并到redis中。

登陆成功后查询cookie中购物车数据，判断是否有数据，如果有数据的话则将购物车的json转化为list集合，遍历集合，将商品合同到redis中。

 

 

 

RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。

 

**AO**F的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。

重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。

**AOF****也有三种触发机制**

（1）每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好

（2）每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失

（3）不同no：从不同步

 