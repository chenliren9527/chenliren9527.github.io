---
title: 面试-分布式接口的幂等设计
tags:
  - 笔记
  - 面试
  - 分布式
categories:
  - 面试
abbrlink: 59446
date: 2021-01-15 16:15:36
---

# 分布式接口的幂等设计

## 什么是接口的幂等性

### 解释

什么是接口的幂等性，接口的幂等性实际上就是**接口可重复调用，在调用方多次调用的情况下，接口最终得到的结果是一致的**。有些接口可以天然的实现幂等性，比如查询接口，对于查询来说，你查询一次和两次，对于系统来说，没有任何影响，查出的结果也是一样。

除了查询功能具有天然的幂等性之外，增加、更新、删除都要保证幂等性。那么如何来保证幂等性呢？

### 举例

在微服务架构下，我们在完成一个订单流程时经常遇到下面的场景：

1. (重复创建)一个订单创建接口，第一次调用超时了，然后调用方重试了一次
2. (重复更新)在订单创建时，我们需要去扣减库存，这时接口发生了超时，调用方重试了一次
3. (重复更新)当这笔订单开始支付，在支付请求发出之后，在服务端发生了扣钱操作，接口响应超时了，调用方重试了一次
4. (无序更新)一个订单状态更新接口，调用方连续发送了两个消息，一个是已创建，一个是已付款。但是你先接收到已付款，然后又接收到了已创建

以上问题，就是在单体架构转成微服务架构之后，带来的问题。当然不是说单体架构下没有这些问题，在单体架构下同样要避免重复请求。但是出现的问题要比这少得多。

## 解决方案

### 全局唯一ID(通用解决方案)

如果使用全局唯一ID，就是根据业务的操作和内容生成一个全局ID，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、redis等。如果存在则表示该方法已经执行。

从工程的角度来说，使用全局ID做幂等可以作为一个业务的基础的微服务存在，在很多的微服务中都会用到这样的服务，在每个微服务中都完成这样的功能，会存在工作量重复。另外打造一个高可靠的幂等服务还需要考虑很多问题，比如一台机器虽然把全局ID先写入了存储，但是在写入之后挂了，这就需要引入全局ID的超时机制。

使用全局唯一ID是一个通用方案，可以支持插入、更新、删除业务操作。但是这个方案看起来很美但是实现起来比较麻烦，下面的方案适用于特定的场景，但是实现起来比较简单。

### 去重表(适用于插入或更新操作)

这种方法适用于在业务中有唯一标识的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和写入到去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。

### 插入或更新(适用于插入或更新)

这种方法插入并且有唯一索引的情况，比如我们要关联商品品类，其中商品的ID和品类的ID可以构成唯一索引，并且在数据表中也增加了唯一索引。这时就可以使用InsertOrUpdate操作。在mysql数据库中如下：

```sql
insert into goods_category (goods_id,category_id,create_time,update_time)
values(#{goodsId},#{categoryId},now(),now())
on DUPLICATE KEY UPDATE
update_time=now()
```



#### 多版本控制(适用于更新)

这种方法适合在更新的场景中，比如我们要更新商品的名字，这时我们就可以在更新的接口中增加一个版本号，来做幂等

在实现时可以如下

```java
boolean updateGoodsName(int id,String newName,int version);
```

```sql
update goods set name=#{newName},version=#{version} where id=#{id} and version<${version}
```



#### 状态机控制(适用于某状态字段有序更新)

这种方法适合在有状态机流转的情况下，比如就会订单的创建和付款，订单的创建肯定是在之前，这时我们可以通过在设计状态字段时，使用int类型，并且通过值类型的大小来做幂等，比如订单的创建为0，付款成功为100。付款失败为99

在做状态机更新时，我们就这可以这样控制

```sql
update `order` set status=#{status} where id=#{id} and status<#{status}
```

以上就是保证接口幂等性的一些方法。