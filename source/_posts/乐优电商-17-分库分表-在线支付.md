---
title: 乐优电商(17)-分库分表&在线支付
tags:
  - 笔记
  - 项目实战二
  - springcloud
  - 微服务
  - 分布式事务
  - Seata
  - Sharding Sphere
  - 分库分表
  - 微信支付
categories:
  - 项目实战二
date: 2021-01-16 18:30:49
---

## 01、课程目标

- 了解分库分表
- 独立搭建ShardingSphere工程

- 微信支付介绍





## 02、分布式事务：安装部署Seata

### 1）安装

第一步：下载：https://github.com/seata/seata/releases

第二步：解压 seata-server-1.3.0

第三步：运行bin下的seata-server.bat

![1580519275975](乐优电商-17-分库分表-在线支付.assets/1580519275975.png) 





### 2）涉及到分布式事务的数据库添加表

seata需要在每个资源服务器中提供一张表：

```sql
CREATE TABLE `undo_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `branch_id` bigint(20) NOT NULL,
  `xid` varchar(100) NOT NULL,
  `context` varchar(128) NOT NULL,
  `rollback_info` longblob NOT NULL,
  `log_status` int(11) NOT NULL,
  `log_created` datetime NOT NULL,
  `log_modified` datetime NOT NULL,
  `ext` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8
```

此表主要用来做分布式事务日志记录，表的位置在seata服务中：

![image-20200402144619244](乐优电商-17-分库分表-在线支付.assets/image-20200402144619244.png)

这里，我们无需单独创建这张表，直接执行资料中提供好的两个数据库sql文件即可：

![image-20200402144711846](乐优电商-17-分库分表-在线支付.assets/image-20200402144711846.png)

效果如下：

![image-20200402144803226](乐优电商-17-分库分表-在线支付.assets/image-20200402144803226.png)





## 03、分布式事务：seata案例演示

### 1） 解压资料中的案例并打开

&nbsp;<img src="../../../../Documents/Java笔记/就业班/10.项目二/day17、分库分表&在线支付/assets/1602940897471.png" alt="1602940897471" style="zoom:67%;" />



### 2） 分布式事务案例业务简单描述

宿舍有两个：

![image-20200402150427851](乐优电商-17-分库分表-在线支付.assets/image-20200402150427851.png)

员工有一个：

![image-20200402150511712](乐优电商-17-分库分表-在线支付.assets/image-20200402150511712.png)

如果宿舍楼切换了，男寝变成了女寝，女寝变成了男寝，对应员工住宿的宿舍楼号也要改变。

### 3） 正常流程

发送请求：

![image-20200402150750275](乐优电商-17-分库分表-在线支付.assets/image-20200402150750275.png)

结果变成：

宿舍

![image-20200402150838530](乐优电商-17-分库分表-在线支付.assets/image-20200402150838530.png)

员工

![image-20200402150900395](乐优电商-17-分库分表-在线支付.assets/image-20200402150900395.png)



### 4） 无分布式事务时出现异常

发送请求：

![image-20200402151151558](乐优电商-17-分库分表-在线支付.assets/image-20200402151151558.png)



结果变成：

宿舍

![image-20200402151245456](乐优电商-17-分库分表-在线支付.assets/image-20200402151245456.png)

员工

![image-20200402151259062](乐优电商-17-分库分表-在线支付.assets/image-20200402151259062.png)



这时，明显出问题了，jackchen是男生，住到2号楼，而2号楼现在是女生宿舍。

宿舍切换失败，但是员工更新宿舍却成功了，没有回滚，导致了这个问题。



### 5） seata自定义SpringBootStarter介绍

整体目录结构

![image-20200402151840193](乐优电商-17-分库分表-在线支付.assets/image-20200402151840193.png)

首先要指定seata的配置方法

![image-20200402151823446](乐优电商-17-分库分表-在线支付.assets/image-20200402151823446.png)

在file.conf中注意seata服务的默认端口

![image-20200402151922771](乐优电商-17-分库分表-在线支付.assets/image-20200402151922771.png)

主配置类讲解

```java
package com.itheima.seata.config;

import com.alibaba.druid.pool.DruidDataSource;
import com.baomidou.mybatisplus.core.MybatisConfiguration;
import com.baomidou.mybatisplus.core.MybatisXMLLanguageDriver;
import io.seata.rm.datasource.DataSourceProxy;
import io.seata.spring.annotation.GlobalTransactionScanner;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.type.JdbcType;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.transaction.SpringManagedTransactionFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.core.env.Environment;

import javax.sql.DataSource;

@Configuration
public class DataSourceConfig {

    /**
     * 创建原有微服务的数据源对象
     * @return
     */
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource druidDataSource() {
        DruidDataSource druidDataSource = new DruidDataSource();
        return druidDataSource;
    }

    /**
     * 把原有的微服务数据源对象放入Seate的代理数据源
     * @param druidDataSource
     * @return
     */
    @Primary
    @Bean("dataSource")
    public DataSourceProxy dataSource(DataSource druidDataSource) {
        return new DataSourceProxy(druidDataSource);
    }

    /**
     * 因为我们项目的底层是MyBatis，又因为DataSource变化为代理数据源，所以SqlSessionFactoryBean重新构建，并设置新的代理数据源
     * @param dataSourceProxy
     * @return
     * @throws Exception
     */
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSourceProxy dataSourceProxy) throws Exception {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSourceProxy);
        MybatisConfiguration configuration = new MybatisConfiguration();
        configuration.setDefaultScriptingLanguage(MybatisXMLLanguageDriver.class);
        configuration.setJdbcTypeForNull(JdbcType.NULL);
        sqlSessionFactoryBean.setConfiguration(configuration);
        sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory());
        return sqlSessionFactoryBean.getObject();
    }

    /**
     * 修改每个注册到Seata的事务组名称
     *      当前spring.application.name为空的时候，取seata.group.name
     *      当前spring.application.name不为空的时候，取spring.application.name
     * @param environment
     * @return
     */
    @Bean
    public GlobalTransactionScanner globalTransactionScanner(Environment environment) {
        //事务分组名称
        String applicationName = environment.getProperty("spring.application.name");
        String groupName = environment.getProperty("seata.group.name");
        if (applicationName == null) {
            return new GlobalTransactionScanner(groupName == null ? "my_test_tx_group" : groupName);
        } else {
            return new GlobalTransactionScanner(applicationName, groupName == null ? "my_test_tx_group" : groupName);
        }
    }


}


```

其实：到此我们可以发现，seata使用起来非常简单，只需要我们使用seata提供的数据源，而且为每个RM资源服务器起个名字即可。

### 6） 把seata服务做成starter

![image-20200402153428952](乐优电商-17-分库分表-在线支付.assets/image-20200402153428952.png)



### 7） 导入每一个RM资源中测试

导入seata启动器配置

&nbsp;![1602941058979](乐优电商-17-分库分表-在线支付.assets/1602941058979.png)



&nbsp;![1602941088713](乐优电商-17-分库分表-在线支付.assets/1602941088713.png)



启动类上面排除SpringBoot数据源自动配置

![1602941310191](乐优电商-17-分库分表-在线支付.assets/1602941310191.png)



&nbsp;![1602941342550](乐优电商-17-分库分表-在线支付.assets/1602941342550.png)



application.yml添加配置允许覆盖SpringBoot自带的对象

![1602941513480](乐优电商-17-分库分表-在线支付.assets/1602941513480.png)



切记，需要在主业务方法上添加@GlobalTransactional注解

如图所示：

![image-20200402154011626](乐优电商-17-分库分表-在线支付.assets/image-20200402154011626.png)

再次测试，不同服务链接不同的数据库，事务都是可以控制在一起的，满足了分布式事务特性。



## 04、分布式事务：乐优商城中使用Seata

### 1） 安装seata-spring-boot-starter及其父工程

![image-20200402154600820](乐优电商-17-分库分表-在线支付.assets/image-20200402154600820.png)

确保本地仓库中有seata-spring-boot-starter的jar包和父工程的jar包

![image-20200402154700932](乐优电商-17-分库分表-在线支付.assets/image-20200402154700932.png)

### 2） 在leyou项目使用seata分布式事务

#### 第一步：在leyou数据库中添加seata日志表

```sql
CREATE TABLE `undo_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `branch_id` bigint(20) NOT NULL,
  `xid` varchar(100) NOT NULL,
  `context` varchar(128) NOT NULL,
  `rollback_info` longblob NOT NULL,
  `log_status` int(11) NOT NULL,
  `log_created` datetime NOT NULL,
  `log_modified` datetime NOT NULL,
  `ext` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8
```

#### 第二步：在所有需要分布式事务的RM资源微服务中导入seata-spring-boot-starter

![image-20200402154956780](乐优电商-17-分库分表-在线支付.assets/image-20200402154956780.png)

![image-20200402155035665](乐优电商-17-分库分表-在线支付.assets/image-20200402155035665.png)



#### 第三步：在启动类上排除SpringBoot内置数据源自动配置

&nbsp;![1602941645472](乐优电商-17-分库分表-在线支付.assets/1602941645472.png)



#### 第四步：在主业务方法中添加@GlobalTransactional注解

![image-20200402155113704](乐优电商-17-分库分表-在线支付.assets/image-20200402155113704.png)

#### 第五步：在所有RM资源微服务中添加配置文件

让Seata的数据源代理对象，覆盖SpringBoot默认的数据源对象

![image-20200402162701775](乐优电商-17-分库分表-在线支付.assets/image-20200402162701775.png)

![image-20200402162722909](乐优电商-17-分库分表-在线支付.assets/image-20200402162722909.png)



#### 第六步：重启测试

重新测试之前下单方法，看看抛出异常时是否可以回滚数据。



## 05、分库分表：数据分片说明

传统的将数据集中存储至单一数据节点的解决方案，在性能、可用性和运维成本这三方面已经难于满足互联网的海量数据场景。

**数据分片**指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。 数据分片的有效手段是对关系型数据库进行分库和分表。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。 除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。 使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。

通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。 数据分片的拆分方式又分为垂直分片和水平分片。 



### 1）垂直分片

按照业务拆分的方式称为垂直分片，又称为纵向拆分，它的核心理念是专库专用。 在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是按照业务将表进行归类，分布到不同的数据库中，从而将压力分散至不同的数据库。 下图展示了根据业务需要，将用户表和订单表垂直分片到不同的数据库的方案。 

![1580911314950](乐优电商-17-分库分表-在线支付.assets/1580911314950.png) 

垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。 垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理。 

 

### 2）水平分片

水平分片又称为横向拆分。 相对于垂直分片，它不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。 例如：根据主键分片，偶数主键的记录放入0库（或表），奇数主键的记录放入1库（或表），如下图所示。 

![1580911437889](乐优电商-17-分库分表-在线支付.assets/1580911437889.png) 



水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案。 





**小结：**

为什么分片：因为数据随着系统的应用越来越大，可能达到数据库可存储的阀值；所以可以根据分片策略将数据按照规则放置到不同的数据库表中。

- **垂直分片**：按照业务划分存放数据，一般专库专用
- **水平分片**：按照数据的字段特征根据一定的算法将这些一条一条的记录保存到不同的数据库表中





## 06、分库分表：Sharding Sphere分库分表说明

### 1）Sharding Sphere简介  

Apache ShardingSphere(Incubator) 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（规划中）这3款相互独立，却又能够混合部署配合使用的产品组成。它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景。

ShardingSphere定位为关系型数据库中间件，旨在充分合理地在分布式的场景下利用关系型数据库的计算和存储能力，而并非实现一个全新的关系型数据库。它通过关注不变，进而抓住事物本质。关系型数据库当今依然占有巨大市场，是各个公司核心业务的基石，未来也难于撼动，我们目前阶段更加关注在原有基础上的增量，而非颠覆。

官网地址：http://shardingsphere.apache.org/index_zh.html 



### 3）数据库准备 

找到 课前资料包下 分库分表目录下的sql脚本 去执行，创建用于测试分库分表的数据库语句。 

![1580912514752](乐优电商-17-分库分表-在线支付.assets/1580912514752.png) 



执行完上述脚本后，会出现两个数据库，每个数据库都会有两张表：

![1580972787378](乐优电商-17-分库分表-在线支付.assets/1580972787378.png) 



### 4）执行逻辑图

![1580974203176](乐优电商-17-分库分表-在线支付.assets/1580974203176.png) 



### 5）分库分表技术对比

- MyCat 也可以进行数据库分库分表；但是mycat是在数据库层面进行的；如果使用了mycat则代码连接数据库的时候；连接的是mycat。所以必须要启动mycat服务器。

- 而Shading sphere 则是在代码层级进行分库分表的，不需要启动任何额外的服务器组件。

![image-20200403092924263](乐优电商-17-分库分表-在线支付.assets/image-20200403092924263.png)







## 07、分库分表：搭建分库分表示例工程并测试

### 1）创建模块导入依赖

![1580973430809](乐优电商-17-分库分表-在线支付.assets/1580973430809.png) 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>leyou</artifactId>
        <groupId>com.leyou</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>ly-sharding-sphere</artifactId>

    <dependencies>
        <!--通用mapper起步依赖-->
         <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.1.0</version>
        </dependency>
        <!--MySQL数据库驱动-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.shardingsphere</groupId>
            <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
            <version>3.1.0</version>
        </dependency>
        <dependency>
            <groupId>io.shardingsphere</groupId>
            <artifactId>sharding-jdbc-spring-namespace</artifactId>
            <version>3.1.0</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>
</project>
```



### 2）创建启动类

```java
package com.leyou;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication
@MapperScan("com.leyou.sharding.mapper")
public class ShardingSphereApplication {
    public static void main(String[] args) {
        SpringApplication.run(ShardingSphereApplication.class, args);
    }
}
```





### 3）编写实体类

```java
package com.leyou.sharding.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;

import java.io.Serializable;
import java.util.Date;

@Data
@TableName("tb_order")
public class Order implements Serializable {
    @TableId(type = IdType.NONE)
    private Long orderId; // 订单编号
    private Long totalFee; // 商品金额
    private Long postFee; // 邮费
    private Long actualFee; // 实付金额
    private Integer paymentType; // 付款方式：1:在线支付, 2:货到付款
    private String promotionIds; // 优惠促销的活动id
    private Long userId; // 用户id
    private Integer status; // 订单状态
    private Date createTime; // 创建时间
    private Date payTime; // 付款时间
    private Date consignTime; // 发货时间
    private Date endTime; // 确认收货时间
    private Date closeTime; // 交易关闭时间
    private Date commentTime; // 评价时间
    private Date updateTime; // 更新时间
    private Integer invoiceType; // 发票类型，0无发票，1普通发票，2电子发票，3增值税发票
    private Integer sourceType; // 订单来源 1:app端，2：pc端，3：微信端
}
```



### 4）编写mapper

```java
package com.leyou.sharding.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.leyou.sharding.entity.Order;

public interface OrderMapper extends BaseMapper<Order> {
}
```



### 5）添加配置文件

```yml
#配置数据源
sharding:
  jdbc:
    datasource:
      #数据库名，名称不能包含下划线
      names: sharding0,sharding1
      sharding0:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.jdbc.Driver
        jdbc-url: jdbc:mysql://127.0.0.1:3306/sharding0?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false&serverTimezone=Asia/Shanghai
        username: root
        password: root
      sharding1:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.jdbc.Driver
        jdbc-url: jdbc:mysql://127.0.0.1:3306/sharding1?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false&serverTimezone=Asia/Shanghai
        username: root
        password: root
    config:
      props:
        sql:
          show: true #显示最终sql语句
      sharding:
        #分库策略；行表达式分片策略
        default-database-strategy:
          inline:
            #分库字段；
            sharding-column: order_id
            # 策略；确定数据进入哪个库
            algorithm-expression: sharding$->{order_id%2}
        tables:
          # 分表策略
          tb_order:
            #数据库表节点
            actual-data-nodes: sharding$->{0..1}.tb_order_$->{1..3}
            # 分表策略
            table-strategy:
              inline:
                # 分表字段
                sharding-column: order_id
                # 策略；确定数据进入哪张表
                algorithm-expression: tb_order_$->{order_id%3 + 1}
            # 主键
            key-generator-column-name: order_id
            key-generator-column-class: SNOWFLAKE

# 开启允许Sharding创建数据源去覆盖SpringBoot自己创建的数据源对象
spring:
  main:
    allow-bean-definition-overriding: true
```



### 6）测试

```java
package com.leyou;

import com.leyou.sharding.mapper.OrderMapper;
import com.leyou.sharding.pojo.Order;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.util.List;
import java.util.Random;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest(classes = ShardingApplication.class)
public class OrderMapperTest {

    @Autowired
    private OrderMapper orderMapper;

    /**
     * 增加
     */
    @Test
    public void testInsert(){
        Order order = null;
        Random random = new Random();

        for(int i=1;i<=100;i++){

            order = new Order();
            order.setUserId(1L);// 使用工具类获取拦截器传递过来的用户id
            order.setStatus(1); // 订单状态
            order.setSourceType(2); // 订单来源 1:app端，2：pc端，3：微信端
            order.setPostFee(0L);// 邮费：全场包邮
            order.setPaymentType(1);// 支付类型：在线支付
            order.setInvoiceType(0);// 发票类型，0无发票，1普通发票，2电子发票，3增值税发票
            order.setActualFee(1L);//实际支付 = 总金额 - 活动金额 ； 这里为了测试我们写个1分
            order.setTotalFee(Long.valueOf(random.nextInt(1000)+i)); // 总金额

            orderMapper.insert(order);

        }

    }

    @Test
    public void testFindAll(){
        List<Order> orders = orderMapper.selectList(null);
        orders.forEach(System.out::println);
        System.out.println(orders.size());
    }

    @Test
    public void testFindById(){
        Order order = orderMapper.selectById(1350380320918081537L);
        System.out.println(order);
    }

}


```





## 08、微信支付：扫码支付流程

### 1）介绍

微信支付官方文档：https://pay.weixin.qq.com/wiki/doc/apiv3/wxpay/pages/api.shtml

![image-20200403102736070](乐优电商-17-分库分表-在线支付.assets/image-20200403102736070.png)

然后选中v2版本

![image-20200403102822664](乐优电商-17-分库分表-在线支付.assets/image-20200403102822664.png)

我们选择开发文档，而后进入选择页面：

https://pay.weixin.qq.com/wiki/doc/api/index.html

![1555642332763](乐优电商-17-分库分表-在线支付.assets/1555642332763.png)

选择native支付，就是扫码支付：

![1527848368179](乐优电商-17-分库分表-在线支付.assets/1527848368179.png)

此处我们使用模式二来开发：

### 2）开发流程

模式二与模式一相比，流程更为简单，不依赖设置的回调支付URL。

商户后台系统先调用微信支付的统一下单接口，微信后台系统返回链接参数code_url；

商户后台系统将code_url值生成二维码图片，用户使用微信客户端扫码后发起支付。

注意：code_url有效期为2小时，过期后扫码不能再发起支付。 

流程图：

![2wa23131](乐优电商-17-分库分表-在线支付.assets/chapter6_5_1.png)

这里我们把商户（我们）要做的事情总结一下：

- 1、商户生成订单
- 2、商户调用微信下单接口，获取code_url支付链接
- 3、商户将链接生成二维码图片，展示给用户；
- 4、支付结果通知：
  - 微信异步通知商户支付结果，商户告知微信支付接收情况
  - 商户如果没有收到通知，可以调用接口，查询支付状态
- 5、如果支付成功，发货，修改订单状态



在前面的业务中，我们已经完成了：

- 1、生成订单

接下来，我们需要做的是：

- 2、调用微信下单接口，生成支付链接。
- 3、根据链接生成二维码图片
- 4、支付成功后修改订单状态





## 09、微信支付：统一下单API请求参数说明

按照上面的步骤分析，第一步是要生成支付链接。我们查看下微信官方文档

在微信支付文档中，可以查询到下面的信息：

> 请求路径

POST请求        URL地址：<https://pay.weixin.qq.com/static/product/product_index.shtml>



> 请求参数

| 字段名     | 变量名           | 必填 | 类型        | 示例值                                 | 描述                                                         |
| :--------- | ---------------- | ---- | ----------- | -------------------------------------- | ------------------------------------------------------------ |
| 公众账号ID | appid            | 是   | String(32)  | wxd678efh56                            | 微信支付分配的公众账号ID                                     |
| 商户号     | mch_id           | 是   | String(32)  | 1230000109                             | 微信支付分配的商户号                                         |
| 随机字符串 | nonce_str        | 是   | String(32)  | 5K8264ILT                              | 随机字符串，长度要求在32位以内。推荐[随机数生成算法](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3) |
| 签名       | sign             | 是   | String(32)  | C380BEC2B                              | 通过签名算法计算得出的签名值，详见[签名生成算法](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3) |
| 商品描述   | body             | 是   | String(128) | 乐优手机                               | 商品简单描述，该字段请按照规范传递，具体请见[参数规定](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_2) |
| 商户订单号 | out_trade_no     | 是   | String(32)  | 20150806125                            | 商户系统内部订单号，要求32个字符内，只能是数字、大小写字母_-\|* 且在同一个商户号下唯一。详见[商户订单号](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_2) |
| 标价金额   | total_fee        | 是   | Int         | 88                                     | 订单总金额，单位为分，详见[支付金额](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_2) |
| 终端IP     | spbill_create_ip | 是   | String(16)  | 123.12.12.123                          | APP和网页支付提交用户端ip，Native支付填调用微信支付API的机器IP。 |
| 通知地址   | notify_url       | 是   | String(256) | http://www.weixin.qq.com/wxpay/pay.php | 异步接收微信支付结果通知的回调地址，通知url必须为外网可访问的url，不能携带参数。 |
| 交易类型   | trade_type       | 是   | String(16)  | JSAPI                                  | JSAPI 公众号支付；NATIVE 扫码支付；APP APP支付说明详见[参数规定](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_2) |

这些参数大致分成3类：

- appid、mch_id、spbill_create_ip、notify_url、trade_type：是商家自己的信息或固定数据，可以提前配置，因此无需每次请求单独配置，而是统一设置好即可，
- nonce_str、sign：是为了保证数据安全而添加的验证数据，根据算法去生成，每次请求自动生成即可。
- body、out_trade_no、total_fee：订单相关信息，需要我们自己填写。





## 10、微信支付：微信SDK介绍

### 1）下载

虽然请求参数比较复杂，但官方已经提供了SDK，供我们使用：![1535979973318](乐优电商-17-分库分表-在线支付.assets/1535979973318.png)

微信没有提供maven仓库坐标，因此我们必须下载使用，建议使用课前资料中，我提供给大家的SDK，其中做了一些必要的设置：

![1580547291437](乐优电商-17-分库分表-在线支付.assets/1580547291437.png) 



 

### 2）WXPay工具

微信SDK提供了一个统一的微信支付工具类：WXPay：

![1580547421923](乐优电商-17-分库分表-在线支付.assets/1580547421923.png) 

其中包含这样一些方法：

com.github.wxpay.sdk.WXPay类下提供了对应的方法：

| 方法名           | 说明             |
| ---------------- | ---------------- |
| microPay         | 刷卡支付         |
| `unifiedOrder`   | **统一下单**     |
| orderQuery       | 查询订单         |
| reverse          | 撤销订单         |
| closeOrder       | 关闭订单         |
| refund           | 申请退款         |
| refundQuery      | 查询退款         |
| downloadBill     | 下载对账单       |
| report           | 交易保障         |
| shortUrl         | 转换短链接       |
| authCodeToOpenid | 授权码查询openid |

- 注意:
  - 参数为`Map<String, String>`对象，返回类型也是`Map<String, String>`
  - 方法内部会将参数转换成含有`appid`、`mch_id`、`nonce_str`、`sign_type`和`sign`的XML
  - 通过HTTPS请求得到返回数据后会对其做必要的处理（例如验证签名，签名错误则抛出异常）

我们主要关注其中的unifiedOrder方法，统一下单：

```java
/**
     * 作用：统一下单<br>
     * 场景：公共号支付、扫码支付、APP支付
     * @param reqData 向wxpay post的请求数据
     * @return API返回数据
     * @throws Exception
     */
public Map<String, String> unifiedOrder(Map<String, String> reqData) throws Exception {
    return this.unifiedOrder(reqData, config.getHttpConnectTimeoutMs(), this.config.getHttpReadTimeoutMs());
}
```

这里的请求参数是：Map<String, String> reqData，就是官方API说明中的请求参数了，不过并不需要我们填写所有参数，而只需要下面的：

- body：商品描述
- out_trade_no：订单编号
- total_fee：订单应支付金额
- spbill_create_ip：设备IP
- notify_url：回调地址
- trade_type：交易类型

剩下的：`appid`、`mch_id`、`nonce_str`、`sign_type`和`sign`参数都有WXPay对象帮我们设置，那么问题来了：这些参数数据WXPay是怎么拿到的呢？

其中，

- nonce_str：是随机字符串，因此由WXPay随机生成，
- sign_type：是签名算法，由WXPay指定，默认是HMACSHA256；
- sign：是签名，有签名算法结合密钥加密而来，因此这里的关键是密钥：key
- appid、mch_id是商家信息，需要配置

也就是说，这例需要配置的包括：appid、mch_id、密钥key。这些从哪里来呢？

看下WXPay的构造函数：

```java
public WXPay(final WXPayConfig config) throws Exception {
    this(config, null, true, false);
}
```

这里需要一个WXPayConfig对象，显然是配置对象。





### 3）WXPayConfig配置

WXPay依赖于WXPayConfig进行配置，那么WXPayConfig是什么呢？

看下源码中的关键部分：

```java
public abstract class WXPayConfig {
    /**
     * 获取 App ID
     *
     * @return App ID
     */
    abstract String getAppID();
    /**
     * 获取 Mch ID
     *
     * @return Mch ID
     */
    abstract String getMchID();
    /**
     * 获取 API 密钥
     *
     * @return API密钥
     */
    abstract String getKey();
    
    // 。。。省略
}
```

这不就是WXPay中需要配置的3个属性嘛，当我们实现这个类，并且给出其中的值，把WXPayConfig传递给WXPay时，WXPay就会获取到这些数据:

![1580547534423](乐优电商-17-分库分表-在线支付.assets/1580547534423.png) 

当我们利用WXPay发送请求时，WXPay就会帮我们封装到请求参数中：

![1580547680115](乐优电商-17-分库分表-在线支付.assets/1580547680115.png) 



而在我提供给大家的SDK中，就编写了一个WXPayConfig的实现：

```java
package com.github.wxpay.sdk;

import lombok.Data;

import java.io.InputStream;

/**
 * @author 黑马程序员
 */
@Data
public class WXPayConfigImpl extends WXPayConfig {
    /**
     * 公众账号ID
     */
    private String appID;
    /**
     * 商户号
     */
    private String mchID;
    /**
     * 生成签名的密钥
     */
    private String key;
    /**
     * 支付回调地址
     */
    private String notifyUrl;
    /**
     * 支付方式
     */
    private String payType;

    public InputStream getCertStream(){
        return null;
    }

    public IWXPayDomain getWXPayDomain(){
        return WXPayDomainSimpleImpl.instance();
    }
}
```

将来我们只需要new出这个实现类对象，并且给这3个参数赋值即可。





## 11、微信支付：打包微信SDK

首先，把我提供的SDK打包并安装到本地的maven仓库，方便在项目中使用。

直接对SDK进行打包，在项目maven中执行如下命令：

```
mvn source:jar install -Dmaven.test.skip=true
```

如图所示：

![image-20200403112617377](乐优电商-17-分库分表-在线支付.assets/image-20200403112617377.png)

控制台效果：

![image-20200403112704681](乐优电商-17-分库分表-在线支付.assets/image-20200403112704681.png) 

然后进入本地仓库查看：

![1580548195135](乐优电商-17-分库分表-在线支付.assets/1580548195135.png) 





## 12、课程总结



1）Seata实现分布式事务

​    1.1 搭建Seata服务器

​    1.2 运行seata案例，阅读seata客户端的配置（regitry.conf配置文件，DataSourceConfig配置类）

​    1.3 把Seata整合到乐优商城中



2）分库分表

​    2.1 了解ShardingSphere分库或分表算法

   2.2 搭建ShardingSphere的工程，测试分库分表的效果



3）微信支付

​     3.1 结合项目抽取支付工具类





