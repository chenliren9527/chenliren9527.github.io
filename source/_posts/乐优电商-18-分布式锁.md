---
title: 乐优电商(18)-分布式锁
tags:
  - 笔记
  - 项目实战二
  - SpringCloud
  - 微服务
  - QRcode
  - 微信支付
  - 内网穿透
  - 分布式锁
  - Redis
  - Redission
  - 秒杀
categories:
  - 项目实战二
date: 2021-01-17 18:31:02
---

## 01、课程目标

- 了解分布式锁



## 02、微信支付：把SDK整合到项目中

### 1）配置WXPay

在ly-order中引入坐标：

```xml
<dependency>
    <groupId>com.github.wxpay</groupId>
    <artifactId>wxpay-sdk</artifactId>
    <version>3.0.9</version>
</dependency>
```



我们将这些WXPayConfig中的属性定义到application.yml中

```yaml
ly:
  pay:
    wx:
      appID: wx8397f8696b538317
      mchID: 1473426802
      key: T6m9iK73b0kn9g5v426MKfHQH7X8rKwb
      notifyUrl: http://api.leyou.com/api/pay/wx/notify
      payType: NATIVE
```

将这些属性注入到PayProperties中：

```java
package com.leyou.order.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 *
 */
@Data
@Component
@ConfigurationProperties(prefix = "ly.pay.wx")
public class PayProperties {
    private String appId;
    private String mchId;
    private String key;
    private String notifyUrl;
    private String payType;
}

```



### 2）支付工具类

创建了配置类后，我们再来初始化WXPay对象，并注入到Spring容器中：

```java
package com.leyou.order.config;

import com.github.wxpay.sdk.PayConfig;
import com.github.wxpay.sdk.WXPay;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 初始化微信支付需要的对象
 */
@Configuration
public class PayConfiguration {
    @Autowired
    private PayProperties payProps;
    
    @Bean
    public WXPay wxPay() throws Exception {
        PayConfig payConfig = new PayConfig();
        payConfig.setAppID(payProps.getAppId());
        payConfig.setMchID(payProps.getMchId());
        payConfig.setKey(payProps.getKey());
        return new WXPay(payConfig);
    }
    
}


```



我们定义支付工具类，完成后续操作：

```java
package com.leyou.order.utils;

import com.github.wxpay.sdk.WXPay;
import com.leyou.common.exception.pojo.LyException;
import com.leyou.order.config.PayProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Component
@Slf4j
public class PayHelper {

    @Autowired
    private WXPay wxPay;
    @Autowired
    private PayProperties payProps;

    /**
     * 生成支付链接
     */
    public String getPayUrl(Long orderId,Long totalFee){
        // 请求参数：
        Map<String, String> data = new HashMap<String, String>();
        data.put("body", "乐优商城-商品订单支付");
        data.put("out_trade_no", orderId.toString());
        data.put("total_fee", totalFee.toString());
        data.put("spbill_create_ip", "123.12.12.123");
        data.put("notify_url", payProps.getNotifyUrl());
        data.put("trade_type", payProps.getPayType());  // 此处指定为扫码支付

        try {
            Map<String, String> resp = wxPay.unifiedOrder(data);

            if(resp.get("return_code").equals("SUCCESS")&&
                    resp.get("result_code").equals("SUCCESS")){
                log.info("【微信支付】生成支付链接成功");
                return resp.get("code_url");
            }else{
                log.error("【微信支付】生成支付链接失败，原因："+resp.get("return_code"));
                throw new LyException(500,"【微信支付】生成支付链接失败");
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new LyException(500,"【微信支付】生成支付链接失败，"+e.getMessage());
        }
    }

}


```



## 03、微信支付：生成微信支付二维码



### 1）获取微信支付链接

在订单支付页面，会向后台发起请求，查询支付的URL地址：

![1555651440971](乐优电商-18-分布式锁.assets/1555651440971.png) 

我们需要编写controller，来实现这个功能：

- 请求方式：GET
- 请求路径：/order/url/{id}
- 请求参数：id，订单的编号
- 返回结果：url地址

代码如下：

OrderController：

```java
/**
     * 生成支付链接
     */
    @GetMapping("/order/url/{id}")
    public ResponseEntity<String> buildPayUrl(@PathVariable("id") Long id){
        String payUrl = orderService.buildPayUrl(id);
        return ResponseEntity.ok(payUrl);
    }
```

service，订单支付url的有效期是2小时，因此我们可以获取url后存入redis缓存：

- 先检查redis是否已经有url，有则返回
- 没有，则查询订单信息，校验订单状态是否为已经支付，是则抛出异常
- 如果没有支付，调用PayHelper，生成url
- 将url存入redis，设置有效期为2小时

在ly-common的常量类中指定支付链接在redis中存储的key的前缀

```java
package com.leyou.common.constant;

public class LyConstants {

    ……

    /*支付链接在redis中存储的key的前缀*/
    public static final String PAY_URL_PRE = "PAY_URL_PRE";
}
```

service代码：

OrderService添加getPayUrl方法：

```java
 public String buildPayUrl(Long id) {

        //1.先到redis取出当前订单的支付链接
        String payUrl = redisTemplate.opsForValue().get("PAY_URL_"+id);
        //2.如果redis有，则直接取出订单的支付链接
        if(StringUtils.isNotEmpty(payUrl)){
            return payUrl;
        }
        
        //3.如果redis没有，则调用微信支付系统生成该订单的支付链接，把该链接存入redis，并设置有效期（2小时）
        //根据订单id查询订单（获取支付金额）
        Order order = orderMapper.selectById(id);
        payUrl = payHelper.getPayUrl(id,order.getActualFee());
        //把该链接存入redis，并设置有效期（2小时）
        redisTemplate.opsForValue().set("PAY_URL_"+id,payUrl,4, TimeUnit.HOURS);
        return payUrl;
    }
```

页面响应结果：

 ![1536017643922](乐优电商-18-分布式锁.assets/1536017643922.png)

支付页面效果：

![image-20200403121210551](乐优电商-18-分布式锁.assets/image-20200403121210551.png)





### 2）根据支付链接生成二维码【了解】

#### 1.什么是二维码

二维码又称QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型。

二维条码/二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。

#### 2.二维码优势

- 信息容量大, 可以容纳多达1850个大写字母或2710个数字或500多个汉字
- 应用范围广, 支持文字,声音,图片,指纹等等...
- 容错能力强, 即使图片出现部分破损也能使用
- 成本低, 容易制作

#### 3.二维码容错级别

- L级（低） 7％的码字可以被恢复。
- M级（中） 15％的码字可以被恢复。
- Q级（四分）25％的码字可以被恢复。
- H级（高）30％ 的码字可以被恢复。

#### 4.二维码生成插件qrious

qrious是一款基于HTML5 Canvas的纯JS二维码生成插件。通过qrious.js可以快速生成各种二维码，你可以控制二维码的尺寸颜色，还可以将生成的二维码进行Base64编码。[官网](https://github.com/davidshimjs/qrcodejs)

qrious.js二维码插件的可用配置参数如下：

| 参数       | 类型   | 默认值      | 描述                               |
| ---------- | ------ | ----------- | ---------------------------------- |
| background | String | "white"     | 二维码的背景颜色。                 |
| foreground | String | "black"     | 二维码的前景颜色。                 |
| level      | String | "L"         | 二维码的误差校正级别(L, M, Q, H)。 |
| mime       | String | "image/png" | 二维码输出为图片时的MIME类型。     |
| size       | Number | 100         | 二维码的尺寸，单位像素。           |
| value      | String | ""          | 需要编码为二维码的值               |

课前资料中给出的案例可以直接生成二维码：

 ![1580608405055](乐优电商-18-分布式锁.assets/1580608405055.png) 



#### 5.生成二维码

我们把课前资料中的这个js脚本引入到项目中：

 ![1528362348399](乐优电商-18-分布式锁.assets/1528362348399.png)

然后在页面引用：

 ![1528362377494](乐优电商-18-分布式锁.assets/1528362377494.png)



页面定义一个div，用于展示二维码：

 ![1528362023061](乐优电商-18-分布式锁.assets/1528362023061.png)

然后获取到付款链接后，根据链接生成二维码：

 ![1528362420151](乐优电商-18-分布式锁.assets/1528362420151.png)





刷新页面，查看效果：

 ![1528362464276](乐优电商-18-分布式锁.assets/1528362464276.png)

此时，客户用手机扫描二维码，可以看到付款页面。

![1580608091413](乐优电商-18-分布式锁.assets/1580608091413.png) 





## 04、微信支付：内网穿透

支付以后，我们后台需要修改订单状态。我们怎么得知有没有支付成功呢？

在我们的请求参数中，有一个notify_url的参数，是支付的回调地址。当用户支付成功后，微信会主动访问这个地址，并携带支付结果信息。

那么，这个notify_url该怎么用呢？

### 1）什么是notify_url

参数中有一个非常重要的，叫做notify_url的：

![1535981510532](乐优电商-18-分布式锁.assets/1535981510532.png)

基于上文的介绍我们知道，这个地址是在支付成功后的异步结果通知。官网介绍如下：

支付完成后，微信会把相关支付结果和用户信息发送给商户，商户需要接收处理，并返回应答。

所以，此处的地址必须是一个外网可访问地址，而且我们要定义好回调的处理接口。

http://api.leyou.com/api/pay/notify



### 2）内网穿透

此处我们肯定不能写：http://api.leyou.com/api/pay/notify，这个域名未经备案，是不被识别的。如何才能获取一个能够外网访问的域名呢？

我们可以通过内网穿透来实现，那么什么是内网穿透呢？

![1535984453478](乐优电商-18-分布式锁.assets/1535984453478.png)

**简单来说内网穿透的目的是：让外网能访问你本地的应用，例如在外网打开你本地http://127.0.0.1指向的Web站点。**



在这里有一篇播客，详细介绍了几种内网穿透策略：[一分钟了解内网穿透](https://blog.csdn.net/zhangguo5/article/details/77848658?utm_source=5ibc.net&utm_medium=referral)



这里我们使用一个免费的内网穿透工具：Natapp：[NATAPP官网](https://natapp.cn)

![1535984650173](乐优电商-18-分布式锁.assets/1535984650173.png)

详细教程在这里：[一分钟的natapp快速新手教程](https://natapp.cn/article/natapp_newbie)

购买隧道：

![image-20200403143232997](乐优电商-18-分布式锁.assets/image-20200403143232997.png)

在我的隧道中记录token：

![image-20200403143307349](乐优电商-18-分布式锁.assets/image-20200403143307349.png)

下载软件：

![image-20200403143339138](乐优电商-18-分布式锁.assets/image-20200403143339138.png)

注意，这里下载的只有软件，没有配置文件，启动的时候，需要手动指定authtoken，资料里面我给大家提供好了一个带有配置文件的软件：

![image-20200403143502640](乐优电商-18-分布式锁.assets/image-20200403143502640.png)

解压：

![image-20200403143723895](乐优电商-18-分布式锁.assets/image-20200403143723895.png)

启动后的样子：

![1580609277957](乐优电商-18-分布式锁.assets/1580609277957.png) 

比如此处，我使用的natapp得到的域名是：http://9xtfjr.natappfree.cc，并且我设置指向到`127.0.0.1:10010`位置，也就是我的网关服务。



### 3）配置回调地址

设置内网穿透地址到配置文件application.yml：

```yaml
ly:
  pay:
    wx:
      appID: wx8397f8696b538317
      mchID: 1473426802
      key: T6m9iK73b0kn9g5v426MKfHQH7X8rKwb
      notifyUrl: http://xn4agt.natappfree.cc/api/pay/wx/notify
      payType: NATIVE
```

WxPayConfigImpl中本来就有notifyURL属性，因此会被自动注入。

### 4）网关白名单

因为异步回调是微信来访问我们的，因此不应该对登录做校验，我们把这个地址配置到白名单，修改ly-gateway中的application.yml

```yaml
ly:
  filter:
    allowPaths:
      - /api/pay
```

然后，将/api/pay映射到订单微服务：

```yaml
        - id: pay-service   # 路由id,可以随意写
          # 代理的服务地址；lb表示负载均衡(从nacos中获取具体服务)
          uri: lb://order-service
          # 路由断言，可以配置映射路径
          predicates:
            - Path=/api/pay/**
          filters:
            # 表示过滤1个路径，2表示两个路径，以此类推
            - StripPrefix=2
```

### 5）订单微服务拦截器对微信的回调地址放开配置

```java
package com.leyou.order.config;

import com.leyou.order.interceptor.UserInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * SpringMVC配置类
 */
@Configuration
public class MvcConfig implements WebMvcConfigurer{
    @Autowired
    private UserInterceptor userInterceptor;

    /**
     * 添加拦截器
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        /**
         * addPathPatterns(): 配置拦截器拦截路径
         * excludePathPatterns()： 配置拦截器排除路径
         */
        registry.addInterceptor(userInterceptor).addPathPatterns("/**").excludePathPatterns("/wx/notify/**");

    }
}


```





## 05、微信支付：微信异步通知

先分析接口需要的四个数据：

- 请求方式：官方文档虽然没有明说，但是测试得出是POST请求
- 请求路径：我们之前指定的notify_url的路径是：/pay/wx/notify
- 请求参数：是xml格式数据，包括支付的结果和状态
- 返回结果：也是xml，表明是否成功

因为要接收xml格式数据，因此我们需要引入解析xml的依赖：

```xml
<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
</dependency>
```

然后编写controller：

```java
/**
     * 支付回调方法
     */
    @PostMapping(value = "/wx/notify",produces = "application/xml")
    public Map<String,String> wxNotify(@RequestBody Map<String,Object> paramMap){
        orderService.wxNotify(paramMap);

        //返回成功信息给微信支付
        Map<String,String> resultMap = new HashMap<>();
        resultMap.put("return_code","SUCCESS");
        resultMap.put("return_msg","OK");
        return resultMap;
    }

```

Service 代码：

service中需要完成下列代码；

- 签名校验
- 数据校验
  - 订单号码校验
  - 订单金额校验
- 更新订单状态

OrderService类中：

```java
public void wxNotify(Map<String, Object> paramMap) {
        //1.订单ID
        Long orderId  = Long.valueOf((String)paramMap.get("out_trade_no"));
        //2.支付金额
        Long totalFee  = Long.valueOf((String)paramMap.get("total_fee"));

        //3.查询订单
        Order order = orderMapper.selectById(orderId);

        if(order==null){
            throw new LyException(500,"订单不存在");
        }

        if(order.getActualFee()!=totalFee){
            throw new LyException(500,"订单金额不正确");
        }

        //修改订单状态
        try {
            order.setStatus(OrderStatusEnum.PAY_UP.value());
            order.setPayTime(new Date());
            orderMapper.updateById(order);
            log.info("【微信通知】更新订单状态成功");
        } catch (Exception e) {
            e.printStackTrace();
            log.error("【微信通知】更新订单状态失败");
            throw new LyException(500,"更新订单状态失败");
        }

    }
```



## 06、微信支付：主动查询支付状态

当用户扫码支付成功，会自动调用回调接口，从而修改订单状态，完成订单支付。

但是，页面上并不知道支付是否成功。怎么办？



### 1）页面查询支付状态

因为不知道用户什么时候会支付，也不知道支付有没有成功，因此页面会采用定时任务，不断查询订单支付的状态：

```js
 // 开启定时任务，查询付款状态
            const taskId = setInterval(() => {
              ly.http.get("/order/state/" + id)
                .then(resp => {
                  let i = resp.data;
                  if (i != 1) {
                    // 付款成功
                    clearInterval(taskId);
                    // 跳转到付款成功页
                    location.href = "/paysuccess.html?orderId=" + id;
                  }
                }).catch((e) => {
                alert("支付状态查询失败，请刷新页面重试。");
                clearInterval(taskId);
              })
            }, 3000);
            // 同时设置一个定时任务，10分钟后，终止查询，认为付款失败
            setTimeout(() => {
              clearInterval(taskId);
              location.href = "/payfail.html?orderId=" + id;
            }, 600000)
          });
```

每隔5秒就会查询一次，为了防止用户一直不支付的情况，又设置了一个定时任务，10分钟后跳转到支付失败页面。



### 2）支付状态查询接口

上面的查询请求 分析：

- 请求方式：Get
- 请求路径 ：/state/{id}
- 请求参数：订单id
- 返回结果：1或者其它，1代表未支付，其它是已经支付

controller：

```java
 /**
     * 查询订单状态
     */
    @GetMapping("/order/state/{id}")
    public ResponseEntity<Integer> checkState(@PathVariable("id") Long id){
        Integer state = orderService.checkState(id);
        return ResponseEntity.ok(state);
    }
```

service：

```java
 public Integer checkState(Long id) {
        Order order = orderMapper.selectById(id);
        return order.getStatus();
    }
```



重启测试：

![1580624775017](乐优电商-18-分布式锁.assets/1580624775017.png) 



## 07、Redis分布式锁：分布式锁版本1

因为Redis具备高性能、高可用、高并发的特性，这里，我们会采用Redis来实现分布式锁。

### 1）Redis分布式锁原理

上面讲过，分布式锁的关键是**多进程共享的内存标记**，因此只要我们在Redis中放置一个这样的标记就可以了。不过在实现过程中，不要忘了我们需要实现下列目标：

- 多进程可见：多进程可见，否则就无法实现分布式效果
- 避免死锁：死锁的情况有很多，我们要思考各种异常导致死锁的情况，保证锁可以被释放
- 排它：同一时刻，只能有一个进程获得锁
- 高可用：避免锁服务宕机或处理好宕机的补救措施

在Redis中我们可以用下面的方式来解决上述问题：

- **多进程可见**：多进程可见，否则就无法实现分布式效果

  - redis本身就是多服务共享的，因此自然满足

- **排它**：同一时刻，只能有一个进程获得锁

  - 我们需要利用Redis的setnx命令来实现，setnx是set when not exits的意思。当多次执行setnx命令时，只有第一次执行的才会成功并返回1，其它情况返回0：
  - ![1555935393771](乐优电商-18-分布式锁.assets/1555935393771.png) 
  - 我们定义一个固定的key，多个进程都执行setnx，设置这个key的值，返回1的服务获取锁，0则没有获取

- **避免死锁**：死锁的情况有很多，我们要思考各种异常导致死锁的情况

  - 比如服务宕机后的锁释放问题，我们设置锁时最好设置锁的有效期，如果服务宕机，有效期到时自动删除锁。

    ![1555935852042](乐优电商-18-分布式锁.assets/1555935852042.png) 

- **高可用**：避免锁服务宕机或处理好宕机的补救措施

  - 利用Redis的主从、哨兵、集群，保证高可用





### 2）分布式锁版本1 - 流程

按照上面所述的理论，分布式锁的流程大概如下：

![1555942085021](乐优电商-18-分布式锁.assets/1555942085021.png) 

基本流程：

- 1、通过set命令设置锁
- 2、判断返回结果是否是OK
  - 1）Nil，获取失败，结束或重试（自旋锁）
  - 2）OK，获取锁成功
    - 执行业务
    - 释放锁，DEL 删除key即可
- 3、异常情况，服务宕机。超时时间EX结束，会自动释放锁

### 3） 搭建分布式锁demo工程

![image-20200405093914301](乐优电商-18-分布式锁.assets/image-20200405093914301.png)

### 4） 导入jar包

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>leyou</artifactId>
        <groupId>com.leyou</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>ly-lock-demo</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

### 5） 提供配置文件

```yml
server:
  port: 9099
spring:
  application:
    name: lock-server
  task:
    scheduling:
      pool:
        size: 2
  redis:
    host: 127.0.0.1
```

### 6） 启动类

```java
package com.leyou;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

/**
 * 分布式锁微服务
 */
@SpringBootApplication
@EnableScheduling // 开启定时任务
public class LyLockApplication {
    public static void main(String[] args) {
        SpringApplication.run(LyLockApplication.class,args);
    }
}

```

### 7） 代码实现

定义一个锁接口：

```java
package com.leyou.lock;

/**
 * 分布式接口
 */
public interface RedisLock {

    //获取锁
    public boolean lock(long locktime);
    //释放锁
    public void unlock();

}

```



先定义一个锁工具：

```java
package com.leyou.lock;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import java.util.concurrent.TimeUnit;

/**
 *
 */
public class RedisLockImpl implements RedisLock{
    private StringRedisTemplate redisTemplate;

    private String key;

    public RedisLockImpl(StringRedisTemplate redisTemplate,String key){
        this.key = key;
        this.redisTemplate =redisTemplate;
    }

    /**
     * 锁对应的值，无意义，写为1
     */
    private static final String value = "1";

    @Override
    public boolean lock(long locktime) {
        //setIfAbsent()方法底层就是发送setnx命令
        /**
         * setnx key value:
             如果该key不存在，则设置key和value到redis，返回1
             如果该key存在，无法设置key和value，返回0
         */
        // 尝试获取锁
        Boolean boo = redisTemplate.opsForValue().setIfAbsent(key, value, locktime, TimeUnit.SECONDS);
        // 判断结果
        return boo != null && boo;
    }

    @Override
    public void unlock() {
        // 删除key即可释放锁
        redisTemplate.delete(key);
    }
}

```

在定时任务中使用锁：

```java
package com.leyou.task;

import com.leyou.lock.RedisLock;
import com.leyou.lock.RedisLockImpl;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * @author 黑马程序员
 */
@Slf4j
@Component
public class HelloJob {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Scheduled(cron = "0/10 * * * * ?")
    public void hello() {
        // 创建锁对象
        RedisLock lock = new RedisLockImpl(redisTemplate,"lock");
        // 获取锁,设置自动失效时间为50s
        boolean isLock = lock.lock(50);
        // 判断是否获取锁
        if (!isLock) {
            // 获取失败
            log.info("获取锁失败，停止定时任务");
            return;
        }
        try {
            // 执行业务
            log.info("获取锁成功，执行定时任务。");
            // 模拟任务耗时
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            log.error("任务执行异常", e);
        } finally {
            // 释放锁
            lock.unlock();
        }
    }
}

```

![1580648963226](乐优电商-18-分布式锁.assets/1580648963226.png) 









## 08、Redis分布式锁：分布式锁版本2

刚才的锁有没有什么问题？

### 1）释放锁的问题

大家思考一下，释放锁就是用DEL语句把锁对应的key给删除，有没有这么一种可能性：

1. 两个进程：A和B和C，在执行任务，并争抢锁，此时A获取了锁，并设置自动过期时间为10s
2. A开始执行业务，因为某种原因，业务阻塞，耗时超过了10秒，此时锁自动释放了
3. B恰好此时开始尝试获取锁，因为锁已经自动释放，成功获取锁
4. A此时业务执行完毕，执行释放锁逻辑（删除key），于是B的锁被释放了，而B其实还在执行业务
5. 此时进程C尝试获取锁，也成功了，因为A把B的锁删除了。

问题出现了：B和C同时获取了锁，违反了排它性！

如何解决这个问题呢？我们应该在删除锁之前，判断这个锁是否是自己设置的锁，如果不是（例如自己的锁已经超时释放），那么就不要删除了。



那么问题来了：**如何得知当前获取锁的是不是自己**呢？

对了，我们可以在set 锁时，存入自己的信息！删除锁前，判断下里面的值是不是与自己相等，如果不等，就不要删除了。

### 2）流程图

来看下流程的变化：

![1555944884321](乐优电商-18-分布式锁.assets/1555944884321.png) 

在释放锁之前，多了一步根据判断，判断锁的value释放跟自己存进去的一致。

### 3）代码实现

```java
package com.leyou.task.lock;

import org.springframework.data.redis.core.StringRedisTemplate;

import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * @author 黑马程序员
 */
public class SimpleRedisLock implements RedisLock{

    private StringRedisTemplate redisTemplate;
    /**
     * 设定好锁对应的 key
     */
    private String key;
    /**
     * 存入的线程信息的前缀，防止与其它JVM中线程信息冲突
     */
    private final String ID_PREFIX = UUID.randomUUID().toString();

    public SimpleRedisLock(StringRedisTemplate redisTemplate, String key) {
        this.redisTemplate = redisTemplate;
        this.key = key;
    }

    public boolean lock(long releaseTime) {
        // 获取线程信息作为值，方便判断是否是自己的锁
        String value = ID_PREFIX + Thread.currentThread().getId();
        // 尝试获取锁
        Boolean boo = redisTemplate.opsForValue().setIfAbsent(key, value, releaseTime, TimeUnit.SECONDS);
        // 判断结果
        return boo != null && boo;
    }

    public void unlock(){
        // 获取线程信息作为值，方便判断是否是自己的锁
        String value = ID_PREFIX + Thread.currentThread().getId();
        // 获取现在的锁的值
        String val = redisTemplate.opsForValue().get(key);
        // 判断是否是自己
        if(value.equals(val)) {
            // 删除key即可释放锁
            redisTemplate.delete(key);
        }
    }
}

```





## 09、Redis分布式锁：分布式锁版本3-分析

刚才的锁有没有什么问题？

如果我们在获取锁以后，执行代码的过程中，再次尝试获取锁，执行setnx肯定会失败，因为锁已经存在了。这样就是**不可重入锁**，有可能导致死锁。

如何解决呢？

当然是想办法改造成**可重入锁**。

### 1）重入锁

什么叫做可重入锁呢？

> 可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。换一种说法：**同一个线程再次进入同步代码时，可以使用自己已获取到的锁。**



可重入锁可以避免因同一线程中多次获取锁而导致死锁发生。



那么，如何实现可重入锁呢？

其中的关键，就是**在锁已经被使用时，判断这个锁是否是自己的，如果是则再次获取**。



我们可以在set锁的值是，**存入获取锁的线程的信息**，这样下次再来时，就能知道当前持有锁的是不是自己，如果是就允许再次获取锁。



要注意，因为锁的获取是**可重入**的，因此必须记录重入的次数，这样不至于在释放锁时一下就释放掉，而是逐层释放。

因此，不能再使用简单的key-value结构，这里推荐使用hash结构：

- key：lock
- hashKey：线程信息
- hashValue：重入次数，默认1



释放锁时，每次都把**重入次数减一**，减到0说明多次获取锁的逻辑都执行完毕，才可以删除key，释放锁



### 2）流程图

这里重点是获取锁的流程：

![1556164092317](乐优电商-18-分布式锁.assets/1556164092317.png) 

下面我们假设锁的key为“`lock`”，hashKey是当前线程的id：“`threadId`”，锁自动释放时间假设为20

获取锁的步骤：

- 1、判断lock是否存在 `EXISTS lock`
  - 存在，说明有人获取锁了，下面判断是不是自己的锁
    - 判断当前线程id作为hashKey是否存在：`HEXISTS lock threadId`
      - 不存在，说明锁已经有了，且不是自己获取的，锁获取失败，end
      - 存在，说明是自己获取的锁，重入次数+1：`HINCRBY lock threadId 1`，去到步骤3
  - 2、不存在，说明可以获取锁，`HSET key threadId 1`
  - 3、设置锁自动释放时间，`EXPIRE lock 20`

释放锁的步骤：

- 1、判断当前线程id作为hashKey是否存在：`HEXISTS lock threadId`
  - 不存在，说明锁已经失效，不用管了
  - 存在，说明锁还在，重入次数减1：`HINCRBY lock threadId -1`，获取新的重入次数
- 2、判断重入次数是否为0：
  - 为0，说明锁全部释放，删除key：`DEL lock`
  - 大于0，说明锁还在使用，重置有效时间：`EXPIRE lock 20`



### 3）实现分析

上述流程有一个最大的问题，就是有大量的判断，这样在多线程运行时，会有线程安全问题，除非能保证**执行**

**命令的原子性**。

因此，这里使用java代码无法实现，那该怎么办呢？

Redis支持一种特殊的执行方式：lua脚本执行，lua脚本中可以定义多条语句，语句执行具备原子性。





## 10、Redis分布式锁：如何执行Lua脚本

其实实现Redis的原子操作有多种方式，比如Redis事务，但是相比而言，使用Redis的Lua脚本更加优秀，具有不可替代的好处：

- 原子性：redis会将整个脚本作为一个整体执行，不会被其他命令插入。
- 复用：客户端发送的脚步会永久存在redis中，以后可以重复使用，而且各个Redis客户端可以共用。
- 高效：Lua脚本解析后会形成缓存，不用每次执行都解析。
- 减少网络开销：Lua脚步缓存后，可以形成SHA值，作为缓存的key，以后调用可以直接根据SHA值来调用脚本，不用每次发送完整脚本，较少网络占用和时延

### 1）Redis脚本命令

通过下面这个命令，可以看到所有脚本相关命令：

```
help @scripting

```



我们看一些常用命令

> EVAL命令：

![1556029159652](乐优电商-18-分布式锁.assets/1556029159652.png) 

直接执行一段脚本，参数包括：

- script：脚本内容，或者脚本地址
- numkeys：脚本中用到的key的数量，接下来的numkeys个参数会作为key参数，剩下的作为arg参数
- key：作为key的参数，会被存入脚本环境中的KEYS数组，角标从1开始
- arg：其它参数，会被存入脚本环境中的ARGV数组，角标从1开始



示例：`EVAL "return 'hello world!'" 0`，其中：

- `"return 'hello world!'"`：就是脚本的内容，直接返回字符串，没有别的命令
- `0`：就是说没有用key参数，直接返回

效果：

![1556030139226](乐优电商-18-分布式锁.assets/1556030139226.png) 



> SCRIPT LOAD命令

![1556029464469](乐优电商-18-分布式锁.assets/1556029464469.png) 

将一段脚本编译并缓存起来，生成一个SHA1值并返回，作为脚本字典的key，方便下次使用。

参数script就是脚本内容或地址。

以之前案例中的的脚本为例：

![1556030196610](乐优电商-18-分布式锁.assets/1556030196610.png) 

此处返回的`ada0bc9efe2392bdcc0083f7f8deaca2da7f32ec`就是脚本缓存后得到的sha1值。

在脚本字典中，每一个这样的sha1值，对应一段解析好的脚本：

![1556030293491](乐优电商-18-分布式锁.assets/1556030293491.png) 



> EVALSHA 命令：

![1556029524238](乐优电商-18-分布式锁.assets/1556029524238.png) 

与EVAL类似，执行一段脚本，区别是通过脚本的sha1值，去脚本缓存中查找，然后执行，参数：

- sha1：就是脚本对应的sha1值

我们用刚刚缓存的脚本为例：

![1556030354363](乐优电商-18-分布式锁.assets/1556030354363.png) 





### 2）lua脚本语法

Lua脚本遵循Lua的基本语法，这里我们简单介绍几个常用的：

> redis.call()和redis.pcall()

这两个函数是调用redis命令的函数，区别在于call执行过程中出现错误会直接返回错误；pcall则在遇到错误后，会继续向下执行。基本语法类似：

```lua
redis.call("命令名称", 参数1， 参数2 ...)

```

例如这样的脚本：`return redis.call('set', KEYS[1], ARGV[1])`

- 'set'：就是执行set 命令
- KEYS[1]：从脚本环境中KEYS数组里取第一个key参数
- ARGV[1]：从脚本环境中ARGV数组里取第一个arg参数

完整示例：

![1556031114634](乐优电商-18-分布式锁.assets/1556031114634.png) 

执行这段脚本时传入的参数：

- 1：声明key只有一个，接下来的第一个参数作为key参数
- name：key参数，会被存入到KEYS数组
- Jack：arg参数，会被存入ARGV数组



> 条件判断和变量

条件判断语法：`if (条件语句) then ...; else ...; end;`

变量接收语法：`local num = 123;`

示例：

```lua
local val = redis.call('get', KEYS[1]);
if (val > ARGV[1]) then 
    return 1; 
else 
	return 0; 
end;

```

基本逻辑：获取指定key的值，判断是否大于指定参数，如果大于则返回1，否则返回0

执行：

![1556032181883](乐优电商-18-分布式锁.assets/1556032181883.png)

- 可以看到num一开始是321。
- 我们保存脚本，
- 然后执行并传递num，400。判断num是否大于400，
- 结果返回0.





## 11、Redis分布式锁：分布式锁版本3-实现

### 1）编写分布式锁脚本

这里我们假设有3个参数：

- KEYS[1]：就是锁的key
- ARGV[1]：就是线程id信息
- ARGV[2]：锁过期时长

首先是获取锁：`lock.lua`

```lua
if (redis.call('EXISTS', KEYS[1]) == 0) then
    redis.call('HSET', KEYS[1], ARGV[1], 1);
    redis.call('EXPIRE', KEYS[1], ARGV[2]);
    return 1;
end;
if (redis.call('HEXISTS', KEYS[1], ARGV[1]) == 1) then
    redis.call('HINCRBY', KEYS[1], ARGV[1], 1);
    redis.call('EXPIRE', KEYS[1], ARGV[2]);
    return 1;
end;
return 0;

```

然后是释放锁：`unlock.lua`

```lua
if (redis.call('HEXISTS', KEYS[1], ARGV[1]) == 0) then
    return nil;
end;
local count = redis.call('HINCRBY', KEYS[1], ARGV[1], -1);
if (count > 0) then
    redis.call('EXPIRE', KEYS[1], ARGV[2]);
    return nil;
else
    redis.call('DEL', KEYS[1]);
    return nil;
end;

```



### 2）Java执行Lua脚本

`RedisTemplate`中提供了一个方法，用来执行Lua脚本：

![1556162076875](乐优电商-18-分布式锁.assets/1556162076875.png)

包含3个参数：

- `RedisScript<T> script`：封装了Lua脚本的对象
- `List<K> keys`：脚本中的key的值
- `Object ... args`：脚本中的参数的值

因此，要执行Lua脚本，我们需要先把脚本封装到`RedisScript`对象中，有两种方式来构建`RedisScript`对象：

> 方式1：

通过RedisScript中的静态方法：

![1556162311151](乐优电商-18-分布式锁.assets/1556162311151.png)

这个方法接受两个参数：

- `String script`：Lua脚本
- `Class<T> resultType`：返回值类型

需要把脚本内容写到代码中，作为参数传递，不够优雅。

> 方式二

另一种方式，就是自己去创建`RedisScript`的实现类`DefaultRedisScript`的对象：

![1556162540499](乐优电商-18-分布式锁.assets/1556162540499.png)

可以把脚本文件写到classpath下的某个位置，然后通过加载这个文件来获取脚本内容，并设置给`DefaultRedisScript`实例。

此处我们选择方式二。

### 3）可重入分布式锁的实现

首先在classpath中编写两个Lua脚本文件：

![1580655530094](乐优电商-18-分布式锁.assets/1580655530094.png) 



然后编写一个新的RedisLock实现：ReentrantRedisLock，利用静态代码块来加载脚本并初始化：

![1580655595587](乐优电商-18-分布式锁.assets/1580655595587.png) 

```java
public class ReentrantRedisLock {
    // 获取锁的脚本
    private static final DefaultRedisScript<Long> LOCK_SCRIPT;
    // 释放锁的脚本
    private static final DefaultRedisScript<Object> UNLOCK_SCRIPT;
    static {
        // 加载释放锁的脚本
        LOCK_SCRIPT = new DefaultRedisScript<>();
        LOCK_SCRIPT.setScriptSource(new ResourceScriptSource(new ClassPathResource("lock.lua")));
        LOCK_SCRIPT.setResultType(Long.class);

        // 加载释放锁的脚本
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setScriptSource(new ResourceScriptSource(new ClassPathResource("unlock.lua")));
    }
    
    // 其它代码略
}

```



然后实现RedisLock并实现lock和unlock方法，完整代码如下：

```java
public class ReentrantRedisLock implements RedisLock {

    private StringRedisTemplate redisTemplate;
    /**
     * 设定好锁对应的 key
     */
    private String key;

    /**
     * 存入的线程信息的前缀，防止与其它JVM中线程信息冲突
     */
    private final String ID_PREFIX = UUID.randomUUID().toString();

    public ReentrantRedisLock(StringRedisTemplate redisTemplate, String key) {
        this.redisTemplate = redisTemplate;
        this.key = key;
    }

    private static final DefaultRedisScript<Long> LOCK_SCRIPT;
    private static final DefaultRedisScript<Object> UNLOCK_SCRIPT;
    static {
        // 加载释放锁的脚本
        LOCK_SCRIPT = new DefaultRedisScript<>();
        LOCK_SCRIPT.setScriptSource(new ResourceScriptSource(new ClassPathResource("lock.lua")));
        LOCK_SCRIPT.setResultType(Long.class);

        // 加载释放锁的脚本
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setScriptSource(new ResourceScriptSource(new ClassPathResource("unlock.lua")));
    }
    // 锁释放时间
    private String releaseTime;

    @Override
    public boolean lock(long releaseTime) {
        // 记录释放时间
        this.releaseTime = String.valueOf(releaseTime);
        // 执行脚本
        Long result = redisTemplate.execute(
                LOCK_SCRIPT,
                Collections.singletonList(key),
                ID_PREFIX + Thread.currentThread().getId(), this.releaseTime);
        // 判断结果
        return result != null && result.intValue() == 1;
    }

    @Override
    public void unlock() {
        // 执行脚本
        redisTemplate.execute(
                UNLOCK_SCRIPT,
                Collections.singletonList(key),
                ID_PREFIX + Thread.currentThread().getId(), this.releaseTime);
    }
}

```

完成！

### 4）测试

新建一个定时任务，测试重入锁：

```java
package com.leyou.task.job;

import com.leyou.task.lock.RedisLock;
import com.leyou.task.lock.ReentrantRedisLock;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * @author 黑马程序员
 */
@Slf4j
@Component
public class ReentrantJob {

    @Autowired
    private StringRedisTemplate redisTemplate;

    private int max = 2;

    @Scheduled(cron = "0/10 * * * * ?")
    public void hello() {
        // 创建锁对象
        RedisLock lock = new ReentrantRedisLock(redisTemplate, "lock");
        // 执行任务
        runTaskWithLock(lock, 1);
    }

    private void runTaskWithLock(RedisLock lock, int count) {
        // 获取锁,设置自动失效时间为50s
        boolean isLock = lock.lock(50);
        // 判断是否获取锁
        if (!isLock) {
            // 获取失败
            log.info("{}层 获取锁失败，停止定时任务", count);
            return;
        }
        try {
            // 执行业务
            log.info("{}层 获取锁成功，执行定时任务。", count);
            Thread.sleep(500);
            if(count < max){
                runTaskWithLock(lock, count + 1);
            }
        } catch (InterruptedException e) {
            log.error("{}层 任务执行失败", count, e);
        } finally {
            // 释放锁
            lock.unlock();
            log.info("{}层 任务执行完毕，释放锁", count);
        }
    }
}

```

DEBUG运行，打断点在获取锁后，执行任务前。





## 12、Redis分布式锁：Redis的集群分布式锁

我们现在实现的分布式锁基本能满足大部分公司的需求，但是在面试的时候，我们这个版本还存在问题。

我们的分布式锁已经实现了： `互斥、原子、可重入、防死锁`

所以为了完美的实现分布式锁，我们要保证redis服务一定不能挂，那意味着我们的redis需要高可用配置，我们可以搭建redis的哨兵主从，从而保证redis高可用。



但是面试官有可能还会扣一个问题，主从的同步需要时间的，虽然是毫秒级别时间，但面试官也会问到，在同步过程中万一刚拿到锁，主服务器还没来得及同步到从服务器就宕机了，那么就存在问题了，怎么办呢？



我们可以使用`连锁`方式，也就是获取锁的时候我们让他们获取多把锁，当这些锁同时获取到了才能真正算是获取锁。

redis官方有解决方案：http://redis.cn/topics/distlock.html

![1580657409240](乐优电商-18-分布式锁.assets/1580657409240.png) 

官方给出的这种其实就是`连锁`方式。





## 13、Redis分布式锁：Redisson



虽然我们已经实现了分布式锁，能够满足大多数情况下的需求，不过我们的代码并不是万无一失。

某些场景下，可能需要实现分布式的不同类型锁，比如：公平锁、互斥锁、可重入锁、读写锁、红锁等等。实现起来比较麻烦。

而开源框架Redission就帮我们实现了上述的这些 锁功能，而且还有很多其它的强大功能。

### 1）什么是Redission

来自官网的一段介绍：

Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(`BitSet`, `Set`, `Multimap`, `SortedSet`, `Map`, `List`, `Queue`, `BlockingQueue`, `Deque`, `BlockingDeque`, `Semaphore`, `Lock`, `AtomicLong`, `CountDownLatch`, `Publish / Subscribe`, `Bloom filter`, `Remote service`, `Spring cache`, `Executor service`, `Live Object service`, `Scheduler service`) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。

[官网地址](https://redisson.org/)：https://redisson.org/

[GitHub地址](https://github.com/redisson/redisson)：https://github.com/redisson/redisson

看看Redission能实现的功能：

![1556163395067](乐优电商-18-分布式锁.assets/1556163395067.png) 

![1556163419648](乐优电商-18-分布式锁.assets/1556163419648.png) 

 ![1556163437101](乐优电商-18-分布式锁.assets/1556163437101.png)

![1556163483872](乐优电商-18-分布式锁.assets/1556163483872.png) 

非常强大而且丰富！



### 2）使用Redission分布式锁

Redission中的分布式锁种类丰富，功能强大，因此使用Redission的分布式锁功能是开发时的首选方案。我们一起来试一下。

#### 1.依赖

引入Redission依赖：

```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.10.6</version>
</dependency>

```

#### 2.配置

配置Redission客户端：

```java
@Configuration
public class RedissonConfig {

    @Bean
    public RedissonClient redisson() throws IOException {
        // 本例子使用的是yaml格式的配置文件，读取使用Config.fromYAML，如果是Json文件，则使用Config.fromJSON
        Config config = Config.fromYAML(RedissonConfig.class.getClassLoader().getResource("redisson-config.yml"));
        return Redisson.create(config);
    }
}
```

注意：这里读取了一个名为RedisProperties的属性，因为我们引入了SpringDataRedis，Spring已经自动加载了RedisProperties，并且读取了配置文件中的Redis信息。

```xml
#Redisson配置
singleServerConfig:
  address: "redis://127.0.0.1:6379"
  password: null
  clientName: null
  database: 7 #选择使用哪个数据库0~15
  idleConnectionTimeout: 10000
  pingTimeout: 1000
  connectTimeout: 10000
  timeout: 3000
  retryAttempts: 3
  retryInterval: 1500
  reconnectionTimeout: 3000
  failedAttempts: 3
  subscriptionsPerConnection: 5
  subscriptionConnectionMinimumIdleSize: 1
  subscriptionConnectionPoolSize: 50
  connectionMinimumIdleSize: 32
  connectionPoolSize: 64
  dnsMonitoringInterval: 5000
  #dnsMonitoring: false

threads: 0
nettyThreads: 0
codec:
  class: "org.redisson.codec.JsonJacksonCodec"
transportMode: "NIO"
```





#### 3.常用API

RedissClient中定义了常见的锁：

![1556169332323](乐优电商-18-分布式锁.assets/1556169332323.png) 

```java
// 创建锁对象，并制定锁的名称
RLock lock = redissonClient.getLock("taskLock");

```



获取锁对象后，可以通过`tryLock()`方法获取锁：

![1556169690541](乐优电商-18-分布式锁.assets/1556169690541.png)

有3个重载的方法：

- 三个参数：获取锁，设置锁等待时间`waitTime`、释放时间`leaseTime`，时间单位`unit`。
  - 如果获取锁失败后，会在`waitTime  `减去获取锁用时的剩余时间段内继续尝试获取锁，如果依然获取失败，则认为获取锁失败；
  - 获取锁后，如果超过`leaseTime`未释放，为避免死锁会自动释放。
- 两个参数：获取锁，设置锁等待时间`time`、时间单位`unit`。释放时间`leaseTime`按照默认的30s
- 空参：获取锁，`waitTime`默认0s，即获取锁失败不重试，`leaseTime`默认30s



任务执行完毕，使用`unlock()`方法释放锁：

![1556170353278](乐优电商-18-分布式锁.assets/1556170353278.png) 



```java
package com.leyou.job;

import com.leyou.lock.RedisLock;
import com.leyou.lock.RedisLockImpl;
import lombok.extern.slf4j.Slf4j;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.concurrent.TimeUnit;

@Slf4j
@Component
public class HelloJob2 {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private RedissonClient redissonClient;

    @Scheduled(cron = "0/5 * * * * ?")
    public void hello() throws InterruptedException {
        //创建Redission锁对象
        RLock lock = redissonClient.getLock("lock");

        //获取锁
        boolean isLock = lock.tryLock(50, TimeUnit.SECONDS);

        try {
            // 执行业务
            log.info("获取锁成功，执行定时任务。");
            // 模拟任务耗时
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            log.error("任务执行异常", e);
        } finally {
            // 释放锁
            lock.unlock();
        }
    }
}
```





## 14、面试题：秒杀解决方案

**秒杀**
	高并发
	高可用

**高并发：**

 - 分布式服务、负载均衡、集群
 - 保证单个服务的QPS足够高
 - 必须尽可能减少单个业务执行时间

![1591929200575](乐优电商-18-分布式锁.assets/1591929200575.png)

![image-20210121231406217](乐优电商-18-分布式锁.assets/image-20210121231406217.png)

## 15、实战准备

